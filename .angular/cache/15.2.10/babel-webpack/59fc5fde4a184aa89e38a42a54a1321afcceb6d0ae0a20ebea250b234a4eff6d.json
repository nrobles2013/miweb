{"ast":null,"code":"/*!\n * Chart.js\n * http://chartjs.org/\n * Version: 2.1.6\n *\n * Copyright 2016 Nick Downie\n * Released under the MIT license\n * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md\n */\n!function (t) {\n  if (\"object\" == typeof exports && \"undefined\" != typeof module) module.exports = t();else if (\"function\" == typeof define && define.amd) define([], t);else {\n    var e;\n    e = \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : this, e.Chart = t();\n  }\n}(function () {\n  return function t(e, a, i) {\n    function n(r, l) {\n      if (!a[r]) {\n        if (!e[r]) {\n          var s = \"function\" == typeof require && require;\n          if (!l && s) return s(r, !0);\n          if (o) return o(r, !0);\n          var d = new Error(\"Cannot find module '\" + r + \"'\");\n          throw d.code = \"MODULE_NOT_FOUND\", d;\n        }\n        var u = a[r] = {\n          exports: {}\n        };\n        e[r][0].call(u.exports, function (t) {\n          var a = e[r][1][t];\n          return n(a ? a : t);\n        }, u, u.exports, t, e, a, i);\n      }\n      return a[r].exports;\n    }\n    for (var o = \"function\" == typeof require && require, r = 0; r < i.length; r++) n(i[r]);\n    return n;\n  }({\n    1: [function (t, e, a) {}, {}],\n    2: [function (t, e, a) {\n      function i(t) {\n        if (t) {\n          var e = /^#([a-fA-F0-9]{3})$/,\n            a = /^#([a-fA-F0-9]{6})$/,\n            i = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\n            n = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\n            o = /(\\w+)/,\n            r = [0, 0, 0],\n            l = 1,\n            s = t.match(e);\n          if (s) {\n            s = s[1];\n            for (var d = 0; d < r.length; d++) r[d] = parseInt(s[d] + s[d], 16);\n          } else if (s = t.match(a)) {\n            s = s[1];\n            for (var d = 0; d < r.length; d++) r[d] = parseInt(s.slice(2 * d, 2 * d + 2), 16);\n          } else if (s = t.match(i)) {\n            for (var d = 0; d < r.length; d++) r[d] = parseInt(s[d + 1]);\n            l = parseFloat(s[4]);\n          } else if (s = t.match(n)) {\n            for (var d = 0; d < r.length; d++) r[d] = Math.round(2.55 * parseFloat(s[d + 1]));\n            l = parseFloat(s[4]);\n          } else if (s = t.match(o)) {\n            if (\"transparent\" == s[1]) return [0, 0, 0, 0];\n            if (r = y[s[1]], !r) return;\n          }\n          for (var d = 0; d < r.length; d++) r[d] = v(r[d], 0, 255);\n          return l = l || 0 == l ? v(l, 0, 1) : 1, r[3] = l, r;\n        }\n      }\n      function n(t) {\n        if (t) {\n          var e = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/,\n            a = t.match(e);\n          if (a) {\n            var i = parseFloat(a[4]),\n              n = v(parseInt(a[1]), 0, 360),\n              o = v(parseFloat(a[2]), 0, 100),\n              r = v(parseFloat(a[3]), 0, 100),\n              l = v(isNaN(i) ? 1 : i, 0, 1);\n            return [n, o, r, l];\n          }\n        }\n      }\n      function o(t) {\n        if (t) {\n          var e = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/,\n            a = t.match(e);\n          if (a) {\n            var i = parseFloat(a[4]),\n              n = v(parseInt(a[1]), 0, 360),\n              o = v(parseFloat(a[2]), 0, 100),\n              r = v(parseFloat(a[3]), 0, 100),\n              l = v(isNaN(i) ? 1 : i, 0, 1);\n            return [n, o, r, l];\n          }\n        }\n      }\n      function r(t) {\n        var e = i(t);\n        return e && e.slice(0, 3);\n      }\n      function l(t) {\n        var e = n(t);\n        return e && e.slice(0, 3);\n      }\n      function s(t) {\n        var e = i(t);\n        return e ? e[3] : (e = n(t)) ? e[3] : (e = o(t)) ? e[3] : void 0;\n      }\n      function d(t) {\n        return \"#\" + x(t[0]) + x(t[1]) + x(t[2]);\n      }\n      function u(t, e) {\n        return 1 > e || t[3] && t[3] < 1 ? c(t, e) : \"rgb(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \")\";\n      }\n      function c(t, e) {\n        return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), \"rgba(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + e + \")\";\n      }\n      function h(t, e) {\n        if (1 > e || t[3] && t[3] < 1) return f(t, e);\n        var a = Math.round(t[0] / 255 * 100),\n          i = Math.round(t[1] / 255 * 100),\n          n = Math.round(t[2] / 255 * 100);\n        return \"rgb(\" + a + \"%, \" + i + \"%, \" + n + \"%)\";\n      }\n      function f(t, e) {\n        var a = Math.round(t[0] / 255 * 100),\n          i = Math.round(t[1] / 255 * 100),\n          n = Math.round(t[2] / 255 * 100);\n        return \"rgba(\" + a + \"%, \" + i + \"%, \" + n + \"%, \" + (e || t[3] || 1) + \")\";\n      }\n      function g(t, e) {\n        return 1 > e || t[3] && t[3] < 1 ? p(t, e) : \"hsl(\" + t[0] + \", \" + t[1] + \"%, \" + t[2] + \"%)\";\n      }\n      function p(t, e) {\n        return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), \"hsla(\" + t[0] + \", \" + t[1] + \"%, \" + t[2] + \"%, \" + e + \")\";\n      }\n      function m(t, e) {\n        return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), \"hwb(\" + t[0] + \", \" + t[1] + \"%, \" + t[2] + \"%\" + (void 0 !== e && 1 !== e ? \", \" + e : \"\") + \")\";\n      }\n      function b(t) {\n        return k[t.slice(0, 3)];\n      }\n      function v(t, e, a) {\n        return Math.min(Math.max(e, t), a);\n      }\n      function x(t) {\n        var e = t.toString(16).toUpperCase();\n        return e.length < 2 ? \"0\" + e : e;\n      }\n      var y = t(6);\n      e.exports = {\n        getRgba: i,\n        getHsla: n,\n        getRgb: r,\n        getHsl: l,\n        getHwb: o,\n        getAlpha: s,\n        hexString: d,\n        rgbString: u,\n        rgbaString: c,\n        percentString: h,\n        percentaString: f,\n        hslString: g,\n        hslaString: p,\n        hwbString: m,\n        keyword: b\n      };\n      var k = {};\n      for (var S in y) k[y[S]] = S;\n    }, {\n      6: 6\n    }],\n    3: [function (t, e, a) {\n      var i = t(5),\n        n = t(2),\n        o = function (t) {\n          if (t instanceof o) return t;\n          if (!(this instanceof o)) return new o(t);\n          this.values = {\n            rgb: [0, 0, 0],\n            hsl: [0, 0, 0],\n            hsv: [0, 0, 0],\n            hwb: [0, 0, 0],\n            cmyk: [0, 0, 0, 0],\n            alpha: 1\n          };\n          var e;\n          if (\"string\" == typeof t) {\n            if (e = n.getRgba(t)) this.setValues(\"rgb\", e);else if (e = n.getHsla(t)) this.setValues(\"hsl\", e);else {\n              if (!(e = n.getHwb(t))) throw new Error('Unable to parse color from string \"' + t + '\"');\n              this.setValues(\"hwb\", e);\n            }\n          } else if (\"object\" == typeof t) if (e = t, void 0 !== e.r || void 0 !== e.red) this.setValues(\"rgb\", e);else if (void 0 !== e.l || void 0 !== e.lightness) this.setValues(\"hsl\", e);else if (void 0 !== e.v || void 0 !== e.value) this.setValues(\"hsv\", e);else if (void 0 !== e.w || void 0 !== e.whiteness) this.setValues(\"hwb\", e);else {\n            if (void 0 === e.c && void 0 === e.cyan) throw new Error(\"Unable to parse color from object \" + JSON.stringify(t));\n            this.setValues(\"cmyk\", e);\n          }\n        };\n      o.prototype = {\n        rgb: function () {\n          return this.setSpace(\"rgb\", arguments);\n        },\n        hsl: function () {\n          return this.setSpace(\"hsl\", arguments);\n        },\n        hsv: function () {\n          return this.setSpace(\"hsv\", arguments);\n        },\n        hwb: function () {\n          return this.setSpace(\"hwb\", arguments);\n        },\n        cmyk: function () {\n          return this.setSpace(\"cmyk\", arguments);\n        },\n        rgbArray: function () {\n          return this.values.rgb;\n        },\n        hslArray: function () {\n          return this.values.hsl;\n        },\n        hsvArray: function () {\n          return this.values.hsv;\n        },\n        hwbArray: function () {\n          var t = this.values;\n          return 1 !== t.alpha ? t.hwb.concat([t.alpha]) : t.hwb;\n        },\n        cmykArray: function () {\n          return this.values.cmyk;\n        },\n        rgbaArray: function () {\n          var t = this.values;\n          return t.rgb.concat([t.alpha]);\n        },\n        hslaArray: function () {\n          var t = this.values;\n          return t.hsl.concat([t.alpha]);\n        },\n        alpha: function (t) {\n          return void 0 === t ? this.values.alpha : (this.setValues(\"alpha\", t), this);\n        },\n        red: function (t) {\n          return this.setChannel(\"rgb\", 0, t);\n        },\n        green: function (t) {\n          return this.setChannel(\"rgb\", 1, t);\n        },\n        blue: function (t) {\n          return this.setChannel(\"rgb\", 2, t);\n        },\n        hue: function (t) {\n          return t && (t %= 360, t = 0 > t ? 360 + t : t), this.setChannel(\"hsl\", 0, t);\n        },\n        saturation: function (t) {\n          return this.setChannel(\"hsl\", 1, t);\n        },\n        lightness: function (t) {\n          return this.setChannel(\"hsl\", 2, t);\n        },\n        saturationv: function (t) {\n          return this.setChannel(\"hsv\", 1, t);\n        },\n        whiteness: function (t) {\n          return this.setChannel(\"hwb\", 1, t);\n        },\n        blackness: function (t) {\n          return this.setChannel(\"hwb\", 2, t);\n        },\n        value: function (t) {\n          return this.setChannel(\"hsv\", 2, t);\n        },\n        cyan: function (t) {\n          return this.setChannel(\"cmyk\", 0, t);\n        },\n        magenta: function (t) {\n          return this.setChannel(\"cmyk\", 1, t);\n        },\n        yellow: function (t) {\n          return this.setChannel(\"cmyk\", 2, t);\n        },\n        black: function (t) {\n          return this.setChannel(\"cmyk\", 3, t);\n        },\n        hexString: function () {\n          return n.hexString(this.values.rgb);\n        },\n        rgbString: function () {\n          return n.rgbString(this.values.rgb, this.values.alpha);\n        },\n        rgbaString: function () {\n          return n.rgbaString(this.values.rgb, this.values.alpha);\n        },\n        percentString: function () {\n          return n.percentString(this.values.rgb, this.values.alpha);\n        },\n        hslString: function () {\n          return n.hslString(this.values.hsl, this.values.alpha);\n        },\n        hslaString: function () {\n          return n.hslaString(this.values.hsl, this.values.alpha);\n        },\n        hwbString: function () {\n          return n.hwbString(this.values.hwb, this.values.alpha);\n        },\n        keyword: function () {\n          return n.keyword(this.values.rgb, this.values.alpha);\n        },\n        rgbNumber: function () {\n          var t = this.values.rgb;\n          return t[0] << 16 | t[1] << 8 | t[2];\n        },\n        luminosity: function () {\n          for (var t = this.values.rgb, e = [], a = 0; a < t.length; a++) {\n            var i = t[a] / 255;\n            e[a] = .03928 >= i ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4);\n          }\n          return .2126 * e[0] + .7152 * e[1] + .0722 * e[2];\n        },\n        contrast: function (t) {\n          var e = this.luminosity(),\n            a = t.luminosity();\n          return e > a ? (e + .05) / (a + .05) : (a + .05) / (e + .05);\n        },\n        level: function (t) {\n          var e = this.contrast(t);\n          return e >= 7.1 ? \"AAA\" : e >= 4.5 ? \"AA\" : \"\";\n        },\n        dark: function () {\n          var t = this.values.rgb,\n            e = (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3;\n          return 128 > e;\n        },\n        light: function () {\n          return !this.dark();\n        },\n        negate: function () {\n          for (var t = [], e = 0; 3 > e; e++) t[e] = 255 - this.values.rgb[e];\n          return this.setValues(\"rgb\", t), this;\n        },\n        lighten: function (t) {\n          var e = this.values.hsl;\n          return e[2] += e[2] * t, this.setValues(\"hsl\", e), this;\n        },\n        darken: function (t) {\n          var e = this.values.hsl;\n          return e[2] -= e[2] * t, this.setValues(\"hsl\", e), this;\n        },\n        saturate: function (t) {\n          var e = this.values.hsl;\n          return e[1] += e[1] * t, this.setValues(\"hsl\", e), this;\n        },\n        desaturate: function (t) {\n          var e = this.values.hsl;\n          return e[1] -= e[1] * t, this.setValues(\"hsl\", e), this;\n        },\n        whiten: function (t) {\n          var e = this.values.hwb;\n          return e[1] += e[1] * t, this.setValues(\"hwb\", e), this;\n        },\n        blacken: function (t) {\n          var e = this.values.hwb;\n          return e[2] += e[2] * t, this.setValues(\"hwb\", e), this;\n        },\n        greyscale: function () {\n          var t = this.values.rgb,\n            e = .3 * t[0] + .59 * t[1] + .11 * t[2];\n          return this.setValues(\"rgb\", [e, e, e]), this;\n        },\n        clearer: function (t) {\n          var e = this.values.alpha;\n          return this.setValues(\"alpha\", e - e * t), this;\n        },\n        opaquer: function (t) {\n          var e = this.values.alpha;\n          return this.setValues(\"alpha\", e + e * t), this;\n        },\n        rotate: function (t) {\n          var e = this.values.hsl,\n            a = (e[0] + t) % 360;\n          return e[0] = 0 > a ? 360 + a : a, this.setValues(\"hsl\", e), this;\n        },\n        mix: function (t, e) {\n          var a = this,\n            i = t,\n            n = void 0 === e ? .5 : e,\n            o = 2 * n - 1,\n            r = a.alpha() - i.alpha(),\n            l = ((o * r === -1 ? o : (o + r) / (1 + o * r)) + 1) / 2,\n            s = 1 - l;\n          return this.rgb(l * a.red() + s * i.red(), l * a.green() + s * i.green(), l * a.blue() + s * i.blue()).alpha(a.alpha() * n + i.alpha() * (1 - n));\n        },\n        toJSON: function () {\n          return this.rgb();\n        },\n        clone: function () {\n          var t,\n            e,\n            a = new o(),\n            i = this.values,\n            n = a.values;\n          for (var r in i) i.hasOwnProperty(r) && (t = i[r], e = {}.toString.call(t), \"[object Array]\" === e ? n[r] = t.slice(0) : \"[object Number]\" === e ? n[r] = t : console.error(\"unexpected color value:\", t));\n          return a;\n        }\n      }, o.prototype.spaces = {\n        rgb: [\"red\", \"green\", \"blue\"],\n        hsl: [\"hue\", \"saturation\", \"lightness\"],\n        hsv: [\"hue\", \"saturation\", \"value\"],\n        hwb: [\"hue\", \"whiteness\", \"blackness\"],\n        cmyk: [\"cyan\", \"magenta\", \"yellow\", \"black\"]\n      }, o.prototype.maxes = {\n        rgb: [255, 255, 255],\n        hsl: [360, 100, 100],\n        hsv: [360, 100, 100],\n        hwb: [360, 100, 100],\n        cmyk: [100, 100, 100, 100]\n      }, o.prototype.getValues = function (t) {\n        for (var e = this.values, a = {}, i = 0; i < t.length; i++) a[t.charAt(i)] = e[t][i];\n        return 1 !== e.alpha && (a.a = e.alpha), a;\n      }, o.prototype.setValues = function (t, e) {\n        var a,\n          n = this.values,\n          o = this.spaces,\n          r = this.maxes,\n          l = 1;\n        if (\"alpha\" === t) l = e;else if (e.length) n[t] = e.slice(0, t.length), l = e[t.length];else if (void 0 !== e[t.charAt(0)]) {\n          for (a = 0; a < t.length; a++) n[t][a] = e[t.charAt(a)];\n          l = e.a;\n        } else if (void 0 !== e[o[t][0]]) {\n          var s = o[t];\n          for (a = 0; a < t.length; a++) n[t][a] = e[s[a]];\n          l = e.alpha;\n        }\n        if (n.alpha = Math.max(0, Math.min(1, void 0 === l ? n.alpha : l)), \"alpha\" === t) return !1;\n        var d;\n        for (a = 0; a < t.length; a++) d = Math.max(0, Math.min(r[t][a], n[t][a])), n[t][a] = Math.round(d);\n        for (var u in o) u !== t && (n[u] = i[t][u](n[t]));\n        return !0;\n      }, o.prototype.setSpace = function (t, e) {\n        var a = e[0];\n        return void 0 === a ? this.getValues(t) : (\"number\" == typeof a && (a = Array.prototype.slice.call(e)), this.setValues(t, a), this);\n      }, o.prototype.setChannel = function (t, e, a) {\n        var i = this.values[t];\n        return void 0 === a ? i[e] : a === i[e] ? this : (i[e] = a, this.setValues(t, i), this);\n      }, \"undefined\" != typeof window && (window.Color = o), e.exports = o;\n    }, {\n      2: 2,\n      5: 5\n    }],\n    4: [function (t, e, a) {\n      function i(t) {\n        var e,\n          a,\n          i,\n          n = t[0] / 255,\n          o = t[1] / 255,\n          r = t[2] / 255,\n          l = Math.min(n, o, r),\n          s = Math.max(n, o, r),\n          d = s - l;\n        return s == l ? e = 0 : n == s ? e = (o - r) / d : o == s ? e = 2 + (r - n) / d : r == s && (e = 4 + (n - o) / d), e = Math.min(60 * e, 360), 0 > e && (e += 360), i = (l + s) / 2, a = s == l ? 0 : .5 >= i ? d / (s + l) : d / (2 - s - l), [e, 100 * a, 100 * i];\n      }\n      function n(t) {\n        var e,\n          a,\n          i,\n          n = t[0],\n          o = t[1],\n          r = t[2],\n          l = Math.min(n, o, r),\n          s = Math.max(n, o, r),\n          d = s - l;\n        return a = 0 == s ? 0 : d / s * 1e3 / 10, s == l ? e = 0 : n == s ? e = (o - r) / d : o == s ? e = 2 + (r - n) / d : r == s && (e = 4 + (n - o) / d), e = Math.min(60 * e, 360), 0 > e && (e += 360), i = s / 255 * 1e3 / 10, [e, a, i];\n      }\n      function o(t) {\n        var e = t[0],\n          a = t[1],\n          n = t[2],\n          o = i(t)[0],\n          r = 1 / 255 * Math.min(e, Math.min(a, n)),\n          n = 1 - 1 / 255 * Math.max(e, Math.max(a, n));\n        return [o, 100 * r, 100 * n];\n      }\n      function l(t) {\n        var e,\n          a,\n          i,\n          n,\n          o = t[0] / 255,\n          r = t[1] / 255,\n          l = t[2] / 255;\n        return n = Math.min(1 - o, 1 - r, 1 - l), e = (1 - o - n) / (1 - n) || 0, a = (1 - r - n) / (1 - n) || 0, i = (1 - l - n) / (1 - n) || 0, [100 * e, 100 * a, 100 * i, 100 * n];\n      }\n      function s(t) {\n        return Q[JSON.stringify(t)];\n      }\n      function d(t) {\n        var e = t[0] / 255,\n          a = t[1] / 255,\n          i = t[2] / 255;\n        e = e > .04045 ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92, a = a > .04045 ? Math.pow((a + .055) / 1.055, 2.4) : a / 12.92, i = i > .04045 ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92;\n        var n = .4124 * e + .3576 * a + .1805 * i,\n          o = .2126 * e + .7152 * a + .0722 * i,\n          r = .0193 * e + .1192 * a + .9505 * i;\n        return [100 * n, 100 * o, 100 * r];\n      }\n      function u(t) {\n        var e,\n          a,\n          i,\n          n = d(t),\n          o = n[0],\n          r = n[1],\n          l = n[2];\n        return o /= 95.047, r /= 100, l /= 108.883, o = o > .008856 ? Math.pow(o, 1 / 3) : 7.787 * o + 16 / 116, r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, l = l > .008856 ? Math.pow(l, 1 / 3) : 7.787 * l + 16 / 116, e = 116 * r - 16, a = 500 * (o - r), i = 200 * (r - l), [e, a, i];\n      }\n      function c(t) {\n        return W(u(t));\n      }\n      function h(t) {\n        var e,\n          a,\n          i,\n          n,\n          o,\n          r = t[0] / 360,\n          l = t[1] / 100,\n          s = t[2] / 100;\n        if (0 == l) return o = 255 * s, [o, o, o];\n        a = .5 > s ? s * (1 + l) : s + l - s * l, e = 2 * s - a, n = [0, 0, 0];\n        for (var d = 0; 3 > d; d++) i = r + 1 / 3 * -(d - 1), 0 > i && i++, i > 1 && i--, o = 1 > 6 * i ? e + 6 * (a - e) * i : 1 > 2 * i ? a : 2 > 3 * i ? e + (a - e) * (2 / 3 - i) * 6 : e, n[d] = 255 * o;\n        return n;\n      }\n      function f(t) {\n        var e,\n          a,\n          i = t[0],\n          n = t[1] / 100,\n          o = t[2] / 100;\n        return 0 === o ? [0, 0, 0] : (o *= 2, n *= 1 >= o ? o : 2 - o, a = (o + n) / 2, e = 2 * n / (o + n), [i, 100 * e, 100 * a]);\n      }\n      function p(t) {\n        return o(h(t));\n      }\n      function m(t) {\n        return l(h(t));\n      }\n      function v(t) {\n        return s(h(t));\n      }\n      function x(t) {\n        var e = t[0] / 60,\n          a = t[1] / 100,\n          i = t[2] / 100,\n          n = Math.floor(e) % 6,\n          o = e - Math.floor(e),\n          r = 255 * i * (1 - a),\n          l = 255 * i * (1 - a * o),\n          s = 255 * i * (1 - a * (1 - o)),\n          i = 255 * i;\n        switch (n) {\n          case 0:\n            return [i, s, r];\n          case 1:\n            return [l, i, r];\n          case 2:\n            return [r, i, s];\n          case 3:\n            return [r, l, i];\n          case 4:\n            return [s, r, i];\n          case 5:\n            return [i, r, l];\n        }\n      }\n      function y(t) {\n        var e,\n          a,\n          i = t[0],\n          n = t[1] / 100,\n          o = t[2] / 100;\n        return a = (2 - n) * o, e = n * o, e /= 1 >= a ? a : 2 - a, e = e || 0, a /= 2, [i, 100 * e, 100 * a];\n      }\n      function k(t) {\n        return o(x(t));\n      }\n      function S(t) {\n        return l(x(t));\n      }\n      function w(t) {\n        return s(x(t));\n      }\n      function C(t) {\n        var e,\n          a,\n          i,\n          n,\n          o = t[0] / 360,\n          l = t[1] / 100,\n          s = t[2] / 100,\n          d = l + s;\n        switch (d > 1 && (l /= d, s /= d), e = Math.floor(6 * o), a = 1 - s, i = 6 * o - e, 0 != (1 & e) && (i = 1 - i), n = l + i * (a - l), e) {\n          default:\n          case 6:\n          case 0:\n            r = a, g = n, b = l;\n            break;\n          case 1:\n            r = n, g = a, b = l;\n            break;\n          case 2:\n            r = l, g = a, b = n;\n            break;\n          case 3:\n            r = l, g = n, b = a;\n            break;\n          case 4:\n            r = n, g = l, b = a;\n            break;\n          case 5:\n            r = a, g = l, b = n;\n        }\n        return [255 * r, 255 * g, 255 * b];\n      }\n      function M(t) {\n        return i(C(t));\n      }\n      function D(t) {\n        return n(C(t));\n      }\n      function A(t) {\n        return l(C(t));\n      }\n      function I(t) {\n        return s(C(t));\n      }\n      function F(t) {\n        var e,\n          a,\n          i,\n          n = t[0] / 100,\n          o = t[1] / 100,\n          r = t[2] / 100,\n          l = t[3] / 100;\n        return e = 1 - Math.min(1, n * (1 - l) + l), a = 1 - Math.min(1, o * (1 - l) + l), i = 1 - Math.min(1, r * (1 - l) + l), [255 * e, 255 * a, 255 * i];\n      }\n      function T(t) {\n        return i(F(t));\n      }\n      function P(t) {\n        return n(F(t));\n      }\n      function _(t) {\n        return o(F(t));\n      }\n      function R(t) {\n        return s(F(t));\n      }\n      function V(t) {\n        var e,\n          a,\n          i,\n          n = t[0] / 100,\n          o = t[1] / 100,\n          r = t[2] / 100;\n        return e = 3.2406 * n + -1.5372 * o + r * -.4986, a = n * -.9689 + 1.8758 * o + .0415 * r, i = .0557 * n + o * -.204 + 1.057 * r, e = e > .0031308 ? 1.055 * Math.pow(e, 1 / 2.4) - .055 : e = 12.92 * e, a = a > .0031308 ? 1.055 * Math.pow(a, 1 / 2.4) - .055 : a = 12.92 * a, i = i > .0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - .055 : i = 12.92 * i, e = Math.min(Math.max(0, e), 1), a = Math.min(Math.max(0, a), 1), i = Math.min(Math.max(0, i), 1), [255 * e, 255 * a, 255 * i];\n      }\n      function O(t) {\n        var e,\n          a,\n          i,\n          n = t[0],\n          o = t[1],\n          r = t[2];\n        return n /= 95.047, o /= 100, r /= 108.883, n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, o = o > .008856 ? Math.pow(o, 1 / 3) : 7.787 * o + 16 / 116, r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, e = 116 * o - 16, a = 500 * (n - o), i = 200 * (o - r), [e, a, i];\n      }\n      function L(t) {\n        return W(O(t));\n      }\n      function B(t) {\n        var e,\n          a,\n          i,\n          n,\n          o = t[0],\n          r = t[1],\n          l = t[2];\n        return 8 >= o ? (a = 100 * o / 903.3, n = 7.787 * (a / 100) + 16 / 116) : (a = 100 * Math.pow((o + 16) / 116, 3), n = Math.pow(a / 100, 1 / 3)), e = .008856 >= e / 95.047 ? e = 95.047 * (r / 500 + n - 16 / 116) / 7.787 : 95.047 * Math.pow(r / 500 + n, 3), i = .008859 >= i / 108.883 ? i = 108.883 * (n - l / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(n - l / 200, 3), [e, a, i];\n      }\n      function W(t) {\n        var e,\n          a,\n          i,\n          n = t[0],\n          o = t[1],\n          r = t[2];\n        return e = Math.atan2(r, o), a = 360 * e / 2 / Math.PI, 0 > a && (a += 360), i = Math.sqrt(o * o + r * r), [n, i, a];\n      }\n      function z(t) {\n        return V(B(t));\n      }\n      function H(t) {\n        var e,\n          a,\n          i,\n          n = t[0],\n          o = t[1],\n          r = t[2];\n        return i = r / 360 * 2 * Math.PI, e = o * Math.cos(i), a = o * Math.sin(i), [n, e, a];\n      }\n      function N(t) {\n        return B(H(t));\n      }\n      function E(t) {\n        return z(H(t));\n      }\n      function U(t) {\n        return G[t];\n      }\n      function q(t) {\n        return i(U(t));\n      }\n      function j(t) {\n        return n(U(t));\n      }\n      function Y(t) {\n        return o(U(t));\n      }\n      function J(t) {\n        return l(U(t));\n      }\n      function X(t) {\n        return u(U(t));\n      }\n      function Z(t) {\n        return d(U(t));\n      }\n      e.exports = {\n        rgb2hsl: i,\n        rgb2hsv: n,\n        rgb2hwb: o,\n        rgb2cmyk: l,\n        rgb2keyword: s,\n        rgb2xyz: d,\n        rgb2lab: u,\n        rgb2lch: c,\n        hsl2rgb: h,\n        hsl2hsv: f,\n        hsl2hwb: p,\n        hsl2cmyk: m,\n        hsl2keyword: v,\n        hsv2rgb: x,\n        hsv2hsl: y,\n        hsv2hwb: k,\n        hsv2cmyk: S,\n        hsv2keyword: w,\n        hwb2rgb: C,\n        hwb2hsl: M,\n        hwb2hsv: D,\n        hwb2cmyk: A,\n        hwb2keyword: I,\n        cmyk2rgb: F,\n        cmyk2hsl: T,\n        cmyk2hsv: P,\n        cmyk2hwb: _,\n        cmyk2keyword: R,\n        keyword2rgb: U,\n        keyword2hsl: q,\n        keyword2hsv: j,\n        keyword2hwb: Y,\n        keyword2cmyk: J,\n        keyword2lab: X,\n        keyword2xyz: Z,\n        xyz2rgb: V,\n        xyz2lab: O,\n        xyz2lch: L,\n        lab2xyz: B,\n        lab2rgb: z,\n        lab2lch: W,\n        lch2lab: H,\n        lch2xyz: N,\n        lch2rgb: E\n      };\n      var G = {\n          aliceblue: [240, 248, 255],\n          antiquewhite: [250, 235, 215],\n          aqua: [0, 255, 255],\n          aquamarine: [127, 255, 212],\n          azure: [240, 255, 255],\n          beige: [245, 245, 220],\n          bisque: [255, 228, 196],\n          black: [0, 0, 0],\n          blanchedalmond: [255, 235, 205],\n          blue: [0, 0, 255],\n          blueviolet: [138, 43, 226],\n          brown: [165, 42, 42],\n          burlywood: [222, 184, 135],\n          cadetblue: [95, 158, 160],\n          chartreuse: [127, 255, 0],\n          chocolate: [210, 105, 30],\n          coral: [255, 127, 80],\n          cornflowerblue: [100, 149, 237],\n          cornsilk: [255, 248, 220],\n          crimson: [220, 20, 60],\n          cyan: [0, 255, 255],\n          darkblue: [0, 0, 139],\n          darkcyan: [0, 139, 139],\n          darkgoldenrod: [184, 134, 11],\n          darkgray: [169, 169, 169],\n          darkgreen: [0, 100, 0],\n          darkgrey: [169, 169, 169],\n          darkkhaki: [189, 183, 107],\n          darkmagenta: [139, 0, 139],\n          darkolivegreen: [85, 107, 47],\n          darkorange: [255, 140, 0],\n          darkorchid: [153, 50, 204],\n          darkred: [139, 0, 0],\n          darksalmon: [233, 150, 122],\n          darkseagreen: [143, 188, 143],\n          darkslateblue: [72, 61, 139],\n          darkslategray: [47, 79, 79],\n          darkslategrey: [47, 79, 79],\n          darkturquoise: [0, 206, 209],\n          darkviolet: [148, 0, 211],\n          deeppink: [255, 20, 147],\n          deepskyblue: [0, 191, 255],\n          dimgray: [105, 105, 105],\n          dimgrey: [105, 105, 105],\n          dodgerblue: [30, 144, 255],\n          firebrick: [178, 34, 34],\n          floralwhite: [255, 250, 240],\n          forestgreen: [34, 139, 34],\n          fuchsia: [255, 0, 255],\n          gainsboro: [220, 220, 220],\n          ghostwhite: [248, 248, 255],\n          gold: [255, 215, 0],\n          goldenrod: [218, 165, 32],\n          gray: [128, 128, 128],\n          green: [0, 128, 0],\n          greenyellow: [173, 255, 47],\n          grey: [128, 128, 128],\n          honeydew: [240, 255, 240],\n          hotpink: [255, 105, 180],\n          indianred: [205, 92, 92],\n          indigo: [75, 0, 130],\n          ivory: [255, 255, 240],\n          khaki: [240, 230, 140],\n          lavender: [230, 230, 250],\n          lavenderblush: [255, 240, 245],\n          lawngreen: [124, 252, 0],\n          lemonchiffon: [255, 250, 205],\n          lightblue: [173, 216, 230],\n          lightcoral: [240, 128, 128],\n          lightcyan: [224, 255, 255],\n          lightgoldenrodyellow: [250, 250, 210],\n          lightgray: [211, 211, 211],\n          lightgreen: [144, 238, 144],\n          lightgrey: [211, 211, 211],\n          lightpink: [255, 182, 193],\n          lightsalmon: [255, 160, 122],\n          lightseagreen: [32, 178, 170],\n          lightskyblue: [135, 206, 250],\n          lightslategray: [119, 136, 153],\n          lightslategrey: [119, 136, 153],\n          lightsteelblue: [176, 196, 222],\n          lightyellow: [255, 255, 224],\n          lime: [0, 255, 0],\n          limegreen: [50, 205, 50],\n          linen: [250, 240, 230],\n          magenta: [255, 0, 255],\n          maroon: [128, 0, 0],\n          mediumaquamarine: [102, 205, 170],\n          mediumblue: [0, 0, 205],\n          mediumorchid: [186, 85, 211],\n          mediumpurple: [147, 112, 219],\n          mediumseagreen: [60, 179, 113],\n          mediumslateblue: [123, 104, 238],\n          mediumspringgreen: [0, 250, 154],\n          mediumturquoise: [72, 209, 204],\n          mediumvioletred: [199, 21, 133],\n          midnightblue: [25, 25, 112],\n          mintcream: [245, 255, 250],\n          mistyrose: [255, 228, 225],\n          moccasin: [255, 228, 181],\n          navajowhite: [255, 222, 173],\n          navy: [0, 0, 128],\n          oldlace: [253, 245, 230],\n          olive: [128, 128, 0],\n          olivedrab: [107, 142, 35],\n          orange: [255, 165, 0],\n          orangered: [255, 69, 0],\n          orchid: [218, 112, 214],\n          palegoldenrod: [238, 232, 170],\n          palegreen: [152, 251, 152],\n          paleturquoise: [175, 238, 238],\n          palevioletred: [219, 112, 147],\n          papayawhip: [255, 239, 213],\n          peachpuff: [255, 218, 185],\n          peru: [205, 133, 63],\n          pink: [255, 192, 203],\n          plum: [221, 160, 221],\n          powderblue: [176, 224, 230],\n          purple: [128, 0, 128],\n          rebeccapurple: [102, 51, 153],\n          red: [255, 0, 0],\n          rosybrown: [188, 143, 143],\n          royalblue: [65, 105, 225],\n          saddlebrown: [139, 69, 19],\n          salmon: [250, 128, 114],\n          sandybrown: [244, 164, 96],\n          seagreen: [46, 139, 87],\n          seashell: [255, 245, 238],\n          sienna: [160, 82, 45],\n          silver: [192, 192, 192],\n          skyblue: [135, 206, 235],\n          slateblue: [106, 90, 205],\n          slategray: [112, 128, 144],\n          slategrey: [112, 128, 144],\n          snow: [255, 250, 250],\n          springgreen: [0, 255, 127],\n          steelblue: [70, 130, 180],\n          tan: [210, 180, 140],\n          teal: [0, 128, 128],\n          thistle: [216, 191, 216],\n          tomato: [255, 99, 71],\n          turquoise: [64, 224, 208],\n          violet: [238, 130, 238],\n          wheat: [245, 222, 179],\n          white: [255, 255, 255],\n          whitesmoke: [245, 245, 245],\n          yellow: [255, 255, 0],\n          yellowgreen: [154, 205, 50]\n        },\n        Q = {};\n      for (var $ in G) Q[JSON.stringify(G[$])] = $;\n    }, {}],\n    5: [function (t, e, a) {\n      var i = t(4),\n        n = function () {\n          return new d();\n        };\n      for (var o in i) {\n        n[o + \"Raw\"] = function (t) {\n          return function (e) {\n            return \"number\" == typeof e && (e = Array.prototype.slice.call(arguments)), i[t](e);\n          };\n        }(o);\n        var r = /(\\w+)2(\\w+)/.exec(o),\n          l = r[1],\n          s = r[2];\n        n[l] = n[l] || {}, n[l][s] = n[o] = function (t) {\n          return function (e) {\n            \"number\" == typeof e && (e = Array.prototype.slice.call(arguments));\n            var a = i[t](e);\n            if (\"string\" == typeof a || void 0 === a) return a;\n            for (var n = 0; n < a.length; n++) a[n] = Math.round(a[n]);\n            return a;\n          };\n        }(o);\n      }\n      var d = function () {\n        this.convs = {};\n      };\n      d.prototype.routeSpace = function (t, e) {\n        var a = e[0];\n        return void 0 === a ? this.getValues(t) : (\"number\" == typeof a && (a = Array.prototype.slice.call(e)), this.setValues(t, a));\n      }, d.prototype.setValues = function (t, e) {\n        return this.space = t, this.convs = {}, this.convs[t] = e, this;\n      }, d.prototype.getValues = function (t) {\n        var e = this.convs[t];\n        if (!e) {\n          var a = this.space,\n            i = this.convs[a];\n          e = n[a][t](i), this.convs[t] = e;\n        }\n        return e;\n      }, [\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function (t) {\n        d.prototype[t] = function (e) {\n          return this.routeSpace(t, arguments);\n        };\n      }), e.exports = n;\n    }, {\n      4: 4\n    }],\n    6: [function (t, e, a) {\n      e.exports = {\n        aliceblue: [240, 248, 255],\n        antiquewhite: [250, 235, 215],\n        aqua: [0, 255, 255],\n        aquamarine: [127, 255, 212],\n        azure: [240, 255, 255],\n        beige: [245, 245, 220],\n        bisque: [255, 228, 196],\n        black: [0, 0, 0],\n        blanchedalmond: [255, 235, 205],\n        blue: [0, 0, 255],\n        blueviolet: [138, 43, 226],\n        brown: [165, 42, 42],\n        burlywood: [222, 184, 135],\n        cadetblue: [95, 158, 160],\n        chartreuse: [127, 255, 0],\n        chocolate: [210, 105, 30],\n        coral: [255, 127, 80],\n        cornflowerblue: [100, 149, 237],\n        cornsilk: [255, 248, 220],\n        crimson: [220, 20, 60],\n        cyan: [0, 255, 255],\n        darkblue: [0, 0, 139],\n        darkcyan: [0, 139, 139],\n        darkgoldenrod: [184, 134, 11],\n        darkgray: [169, 169, 169],\n        darkgreen: [0, 100, 0],\n        darkgrey: [169, 169, 169],\n        darkkhaki: [189, 183, 107],\n        darkmagenta: [139, 0, 139],\n        darkolivegreen: [85, 107, 47],\n        darkorange: [255, 140, 0],\n        darkorchid: [153, 50, 204],\n        darkred: [139, 0, 0],\n        darksalmon: [233, 150, 122],\n        darkseagreen: [143, 188, 143],\n        darkslateblue: [72, 61, 139],\n        darkslategray: [47, 79, 79],\n        darkslategrey: [47, 79, 79],\n        darkturquoise: [0, 206, 209],\n        darkviolet: [148, 0, 211],\n        deeppink: [255, 20, 147],\n        deepskyblue: [0, 191, 255],\n        dimgray: [105, 105, 105],\n        dimgrey: [105, 105, 105],\n        dodgerblue: [30, 144, 255],\n        firebrick: [178, 34, 34],\n        floralwhite: [255, 250, 240],\n        forestgreen: [34, 139, 34],\n        fuchsia: [255, 0, 255],\n        gainsboro: [220, 220, 220],\n        ghostwhite: [248, 248, 255],\n        gold: [255, 215, 0],\n        goldenrod: [218, 165, 32],\n        gray: [128, 128, 128],\n        green: [0, 128, 0],\n        greenyellow: [173, 255, 47],\n        grey: [128, 128, 128],\n        honeydew: [240, 255, 240],\n        hotpink: [255, 105, 180],\n        indianred: [205, 92, 92],\n        indigo: [75, 0, 130],\n        ivory: [255, 255, 240],\n        khaki: [240, 230, 140],\n        lavender: [230, 230, 250],\n        lavenderblush: [255, 240, 245],\n        lawngreen: [124, 252, 0],\n        lemonchiffon: [255, 250, 205],\n        lightblue: [173, 216, 230],\n        lightcoral: [240, 128, 128],\n        lightcyan: [224, 255, 255],\n        lightgoldenrodyellow: [250, 250, 210],\n        lightgray: [211, 211, 211],\n        lightgreen: [144, 238, 144],\n        lightgrey: [211, 211, 211],\n        lightpink: [255, 182, 193],\n        lightsalmon: [255, 160, 122],\n        lightseagreen: [32, 178, 170],\n        lightskyblue: [135, 206, 250],\n        lightslategray: [119, 136, 153],\n        lightslategrey: [119, 136, 153],\n        lightsteelblue: [176, 196, 222],\n        lightyellow: [255, 255, 224],\n        lime: [0, 255, 0],\n        limegreen: [50, 205, 50],\n        linen: [250, 240, 230],\n        magenta: [255, 0, 255],\n        maroon: [128, 0, 0],\n        mediumaquamarine: [102, 205, 170],\n        mediumblue: [0, 0, 205],\n        mediumorchid: [186, 85, 211],\n        mediumpurple: [147, 112, 219],\n        mediumseagreen: [60, 179, 113],\n        mediumslateblue: [123, 104, 238],\n        mediumspringgreen: [0, 250, 154],\n        mediumturquoise: [72, 209, 204],\n        mediumvioletred: [199, 21, 133],\n        midnightblue: [25, 25, 112],\n        mintcream: [245, 255, 250],\n        mistyrose: [255, 228, 225],\n        moccasin: [255, 228, 181],\n        navajowhite: [255, 222, 173],\n        navy: [0, 0, 128],\n        oldlace: [253, 245, 230],\n        olive: [128, 128, 0],\n        olivedrab: [107, 142, 35],\n        orange: [255, 165, 0],\n        orangered: [255, 69, 0],\n        orchid: [218, 112, 214],\n        palegoldenrod: [238, 232, 170],\n        palegreen: [152, 251, 152],\n        paleturquoise: [175, 238, 238],\n        palevioletred: [219, 112, 147],\n        papayawhip: [255, 239, 213],\n        peachpuff: [255, 218, 185],\n        peru: [205, 133, 63],\n        pink: [255, 192, 203],\n        plum: [221, 160, 221],\n        powderblue: [176, 224, 230],\n        purple: [128, 0, 128],\n        rebeccapurple: [102, 51, 153],\n        red: [255, 0, 0],\n        rosybrown: [188, 143, 143],\n        royalblue: [65, 105, 225],\n        saddlebrown: [139, 69, 19],\n        salmon: [250, 128, 114],\n        sandybrown: [244, 164, 96],\n        seagreen: [46, 139, 87],\n        seashell: [255, 245, 238],\n        sienna: [160, 82, 45],\n        silver: [192, 192, 192],\n        skyblue: [135, 206, 235],\n        slateblue: [106, 90, 205],\n        slategray: [112, 128, 144],\n        slategrey: [112, 128, 144],\n        snow: [255, 250, 250],\n        springgreen: [0, 255, 127],\n        steelblue: [70, 130, 180],\n        tan: [210, 180, 140],\n        teal: [0, 128, 128],\n        thistle: [216, 191, 216],\n        tomato: [255, 99, 71],\n        turquoise: [64, 224, 208],\n        violet: [238, 130, 238],\n        wheat: [245, 222, 179],\n        white: [255, 255, 255],\n        whitesmoke: [245, 245, 245],\n        yellow: [255, 255, 0],\n        yellowgreen: [154, 205, 50]\n      };\n    }, {}],\n    7: [function (t, e, a) {\n      var i = t(26)();\n      t(25)(i), t(24)(i), t(21)(i), t(22)(i), t(23)(i), t(27)(i), t(31)(i), t(29)(i), t(30)(i), t(32)(i), t(28)(i), t(33)(i), t(34)(i), t(35)(i), t(36)(i), t(37)(i), t(40)(i), t(38)(i), t(39)(i), t(41)(i), t(42)(i), t(43)(i), t(15)(i), t(16)(i), t(17)(i), t(18)(i), t(19)(i), t(20)(i), t(8)(i), t(9)(i), t(10)(i), t(11)(i), t(12)(i), t(13)(i), t(14)(i), window.Chart = e.exports = i;\n    }, {\n      10: 10,\n      11: 11,\n      12: 12,\n      13: 13,\n      14: 14,\n      15: 15,\n      16: 16,\n      17: 17,\n      18: 18,\n      19: 19,\n      20: 20,\n      21: 21,\n      22: 22,\n      23: 23,\n      24: 24,\n      25: 25,\n      26: 26,\n      27: 27,\n      28: 28,\n      29: 29,\n      30: 30,\n      31: 31,\n      32: 32,\n      33: 33,\n      34: 34,\n      35: 35,\n      36: 36,\n      37: 37,\n      38: 38,\n      39: 39,\n      40: 40,\n      41: 41,\n      42: 42,\n      43: 43,\n      8: 8,\n      9: 9\n    }],\n    8: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        t.Bar = function (e, a) {\n          return a.type = \"bar\", new t(e, a);\n        };\n      };\n    }, {}],\n    9: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        t.Bubble = function (e, a) {\n          return a.type = \"bubble\", new t(e, a);\n        };\n      };\n    }, {}],\n    10: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        t.Doughnut = function (e, a) {\n          return a.type = \"doughnut\", new t(e, a);\n        };\n      };\n    }, {}],\n    11: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        t.Line = function (e, a) {\n          return a.type = \"line\", new t(e, a);\n        };\n      };\n    }, {}],\n    12: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        t.PolarArea = function (e, a) {\n          return a.type = \"polarArea\", new t(e, a);\n        };\n      };\n    }, {}],\n    13: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        t.Radar = function (e, a) {\n          return a.options = t.helpers.configMerge({\n            aspectRatio: 1\n          }, a.options), a.type = \"radar\", new t(e, a);\n        };\n      };\n    }, {}],\n    14: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = {\n          hover: {\n            mode: \"single\"\n          },\n          scales: {\n            xAxes: [{\n              type: \"linear\",\n              position: \"bottom\",\n              id: \"x-axis-1\"\n            }],\n            yAxes: [{\n              type: \"linear\",\n              position: \"left\",\n              id: \"y-axis-1\"\n            }]\n          },\n          tooltips: {\n            callbacks: {\n              title: function (t, e) {\n                return \"\";\n              },\n              label: function (t, e) {\n                return \"(\" + t.xLabel + \", \" + t.yLabel + \")\";\n              }\n            }\n          }\n        };\n        t.defaults.scatter = e, t.controllers.scatter = t.controllers.line, t.Scatter = function (e, a) {\n          return a.type = \"scatter\", new t(e, a);\n        };\n      };\n    }, {}],\n    15: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers;\n        t.defaults.bar = {\n          hover: {\n            mode: \"label\"\n          },\n          scales: {\n            xAxes: [{\n              type: \"category\",\n              categoryPercentage: .8,\n              barPercentage: .9,\n              gridLines: {\n                offsetGridLines: !0\n              }\n            }],\n            yAxes: [{\n              type: \"linear\"\n            }]\n          }\n        }, t.controllers.bar = t.DatasetController.extend({\n          dataElementType: t.elements.Rectangle,\n          initialize: function (e, a) {\n            t.DatasetController.prototype.initialize.call(this, e, a), this.getMeta().bar = !0;\n          },\n          getBarCount: function () {\n            var t = this,\n              a = 0;\n            return e.each(t.chart.data.datasets, function (e, i) {\n              var n = t.chart.getDatasetMeta(i);\n              n.bar && t.chart.isDatasetVisible(i) && ++a;\n            }, t), a;\n          },\n          update: function (t) {\n            var a = this;\n            e.each(a.getMeta().data, function (e, i) {\n              a.updateElement(e, i, t);\n            }, a);\n          },\n          updateElement: function (t, a, i) {\n            var n = this,\n              o = n.getMeta(),\n              r = n.getScaleForId(o.xAxisID),\n              l = n.getScaleForId(o.yAxisID),\n              s = l.getBasePixel(),\n              d = n.chart.options.elements.rectangle,\n              u = t.custom || {},\n              c = n.getDataset();\n            e.extend(t, {\n              _xScale: r,\n              _yScale: l,\n              _datasetIndex: n.index,\n              _index: a,\n              _model: {\n                x: n.calculateBarX(a, n.index),\n                y: i ? s : n.calculateBarY(a, n.index),\n                label: n.chart.data.labels[a],\n                datasetLabel: c.label,\n                base: i ? s : n.calculateBarBase(n.index, a),\n                width: n.calculateBarWidth(a),\n                backgroundColor: u.backgroundColor ? u.backgroundColor : e.getValueAtIndexOrDefault(c.backgroundColor, a, d.backgroundColor),\n                borderSkipped: u.borderSkipped ? u.borderSkipped : d.borderSkipped,\n                borderColor: u.borderColor ? u.borderColor : e.getValueAtIndexOrDefault(c.borderColor, a, d.borderColor),\n                borderWidth: u.borderWidth ? u.borderWidth : e.getValueAtIndexOrDefault(c.borderWidth, a, d.borderWidth)\n              }\n            }), t.pivot();\n          },\n          calculateBarBase: function (t, e) {\n            var a = this,\n              i = a.getMeta(),\n              n = a.getScaleForId(i.yAxisID),\n              o = 0;\n            if (n.options.stacked) {\n              var r = a.chart,\n                l = r.data.datasets,\n                s = l[t].data[e];\n              if (0 > s) for (var d = 0; t > d; d++) {\n                var u = l[d],\n                  c = r.getDatasetMeta(d);\n                c.bar && c.yAxisID === n.id && r.isDatasetVisible(d) && (o += u.data[e] < 0 ? u.data[e] : 0);\n              } else for (var h = 0; t > h; h++) {\n                var f = l[h],\n                  g = r.getDatasetMeta(h);\n                g.bar && g.yAxisID === n.id && r.isDatasetVisible(h) && (o += f.data[e] > 0 ? f.data[e] : 0);\n              }\n              return n.getPixelForValue(o);\n            }\n            return n.getBasePixel();\n          },\n          getRuler: function (t) {\n            var e,\n              a = this,\n              i = a.getMeta(),\n              n = a.getScaleForId(i.xAxisID),\n              o = a.getBarCount();\n            e = \"category\" === n.options.type ? n.getPixelForTick(t + 1) - n.getPixelForTick(t) : n.width / n.ticks.length;\n            var r = e * n.options.categoryPercentage,\n              l = (e - e * n.options.categoryPercentage) / 2,\n              s = r / o;\n            if (n.ticks.length !== a.chart.data.labels.length) {\n              var d = n.ticks.length / a.chart.data.labels.length;\n              s *= d;\n            }\n            var u = s * n.options.barPercentage,\n              c = s - s * n.options.barPercentage;\n            return {\n              datasetCount: o,\n              tickWidth: e,\n              categoryWidth: r,\n              categorySpacing: l,\n              fullBarWidth: s,\n              barWidth: u,\n              barSpacing: c\n            };\n          },\n          calculateBarWidth: function (t) {\n            var e = this.getScaleForId(this.getMeta().xAxisID),\n              a = this.getRuler(t);\n            return e.options.stacked ? a.categoryWidth : a.barWidth;\n          },\n          getBarIndex: function (t) {\n            var e,\n              a,\n              i = 0;\n            for (a = 0; t > a; ++a) e = this.chart.getDatasetMeta(a), e.bar && this.chart.isDatasetVisible(a) && ++i;\n            return i;\n          },\n          calculateBarX: function (t, e) {\n            var a = this,\n              i = a.getMeta(),\n              n = a.getScaleForId(i.xAxisID),\n              o = a.getBarIndex(e),\n              r = a.getRuler(t),\n              l = n.getPixelForValue(null, t, e, a.chart.isCombo);\n            return l -= a.chart.isCombo ? r.tickWidth / 2 : 0, n.options.stacked ? l + r.categoryWidth / 2 + r.categorySpacing : l + r.barWidth / 2 + r.categorySpacing + r.barWidth * o + r.barSpacing / 2 + r.barSpacing * o;\n          },\n          calculateBarY: function (t, e) {\n            var a = this,\n              i = a.getMeta(),\n              n = a.getScaleForId(i.yAxisID),\n              o = a.getDataset().data[t];\n            if (n.options.stacked) {\n              for (var r = 0, l = 0, s = 0; e > s; s++) {\n                var d = a.chart.data.datasets[s],\n                  u = a.chart.getDatasetMeta(s);\n                u.bar && u.yAxisID === n.id && a.chart.isDatasetVisible(s) && (d.data[t] < 0 ? l += d.data[t] || 0 : r += d.data[t] || 0);\n              }\n              return 0 > o ? n.getPixelForValue(l + o) : n.getPixelForValue(r + o);\n            }\n            return n.getPixelForValue(o);\n          },\n          draw: function (t) {\n            var a = this,\n              i = t || 1;\n            e.each(a.getMeta().data, function (t, e) {\n              var n = a.getDataset().data[e];\n              null === n || void 0 === n || isNaN(n) || t.transition(i).draw();\n            }, a);\n          },\n          setHoverStyle: function (t) {\n            var a = this.chart.data.datasets[t._datasetIndex],\n              i = t._index,\n              n = t.custom || {},\n              o = t._model;\n            o.backgroundColor = n.hoverBackgroundColor ? n.hoverBackgroundColor : e.getValueAtIndexOrDefault(a.hoverBackgroundColor, i, e.getHoverColor(o.backgroundColor)), o.borderColor = n.hoverBorderColor ? n.hoverBorderColor : e.getValueAtIndexOrDefault(a.hoverBorderColor, i, e.getHoverColor(o.borderColor)), o.borderWidth = n.hoverBorderWidth ? n.hoverBorderWidth : e.getValueAtIndexOrDefault(a.hoverBorderWidth, i, o.borderWidth);\n          },\n          removeHoverStyle: function (t) {\n            var a = this.chart.data.datasets[t._datasetIndex],\n              i = t._index,\n              n = t.custom || {},\n              o = t._model,\n              r = this.chart.options.elements.rectangle;\n            o.backgroundColor = n.backgroundColor ? n.backgroundColor : e.getValueAtIndexOrDefault(a.backgroundColor, i, r.backgroundColor), o.borderColor = n.borderColor ? n.borderColor : e.getValueAtIndexOrDefault(a.borderColor, i, r.borderColor), o.borderWidth = n.borderWidth ? n.borderWidth : e.getValueAtIndexOrDefault(a.borderWidth, i, r.borderWidth);\n          }\n        }), t.defaults.horizontalBar = {\n          hover: {\n            mode: \"label\"\n          },\n          scales: {\n            xAxes: [{\n              type: \"linear\",\n              position: \"bottom\"\n            }],\n            yAxes: [{\n              position: \"left\",\n              type: \"category\",\n              categoryPercentage: .8,\n              barPercentage: .9,\n              gridLines: {\n                offsetGridLines: !0\n              }\n            }]\n          },\n          elements: {\n            rectangle: {\n              borderSkipped: \"left\"\n            }\n          },\n          tooltips: {\n            callbacks: {\n              title: function (t, e) {\n                var a = \"\";\n                return t.length > 0 && (t[0].yLabel ? a = t[0].yLabel : e.labels.length > 0 && t[0].index < e.labels.length && (a = e.labels[t[0].index])), a;\n              },\n              label: function (t, e) {\n                var a = e.datasets[t.datasetIndex].label || \"\";\n                return a + \": \" + t.xLabel;\n              }\n            }\n          }\n        }, t.controllers.horizontalBar = t.controllers.bar.extend({\n          updateElement: function (t, a, i, n) {\n            var o = this,\n              r = o.getMeta(),\n              l = o.getScaleForId(r.xAxisID),\n              s = o.getScaleForId(r.yAxisID),\n              d = l.getBasePixel(),\n              u = t.custom || {},\n              c = o.getDataset(),\n              h = o.chart.options.elements.rectangle;\n            e.extend(t, {\n              _xScale: l,\n              _yScale: s,\n              _datasetIndex: o.index,\n              _index: a,\n              _model: {\n                x: i ? d : o.calculateBarX(a, o.index),\n                y: o.calculateBarY(a, o.index),\n                label: o.chart.data.labels[a],\n                datasetLabel: c.label,\n                base: i ? d : o.calculateBarBase(o.index, a),\n                height: o.calculateBarHeight(a),\n                backgroundColor: u.backgroundColor ? u.backgroundColor : e.getValueAtIndexOrDefault(c.backgroundColor, a, h.backgroundColor),\n                borderSkipped: u.borderSkipped ? u.borderSkipped : h.borderSkipped,\n                borderColor: u.borderColor ? u.borderColor : e.getValueAtIndexOrDefault(c.borderColor, a, h.borderColor),\n                borderWidth: u.borderWidth ? u.borderWidth : e.getValueAtIndexOrDefault(c.borderWidth, a, h.borderWidth)\n              },\n              draw: function () {\n                function t(t) {\n                  return s[(u + t) % 4];\n                }\n                var e = this._chart.ctx,\n                  a = this._view,\n                  i = a.height / 2,\n                  n = a.y - i,\n                  o = a.y + i,\n                  r = a.base - (a.base - a.x),\n                  l = a.borderWidth / 2;\n                a.borderWidth && (n += l, o -= l, r += l), e.beginPath(), e.fillStyle = a.backgroundColor, e.strokeStyle = a.borderColor, e.lineWidth = a.borderWidth;\n                var s = [[a.base, o], [a.base, n], [r, n], [r, o]],\n                  d = [\"bottom\", \"left\", \"top\", \"right\"],\n                  u = d.indexOf(a.borderSkipped, 0);\n                -1 === u && (u = 0), e.moveTo.apply(e, t(0));\n                for (var c = 1; 4 > c; c++) e.lineTo.apply(e, t(c));\n                e.fill(), a.borderWidth && e.stroke();\n              },\n              inRange: function (t, e) {\n                var a = this._view,\n                  i = !1;\n                return a && (i = a.x < a.base ? e >= a.y - a.height / 2 && e <= a.y + a.height / 2 && t >= a.x && t <= a.base : e >= a.y - a.height / 2 && e <= a.y + a.height / 2 && t >= a.base && t <= a.x), i;\n              }\n            }), t.pivot();\n          },\n          calculateBarBase: function (t, e) {\n            var a = this,\n              i = a.getMeta(),\n              n = a.getScaleForId(i.xAxisID),\n              o = 0;\n            if (n.options.stacked) {\n              var r = a.chart.data.datasets[t].data[e];\n              if (0 > r) for (var l = 0; t > l; l++) {\n                var s = a.chart.data.datasets[l],\n                  d = a.chart.getDatasetMeta(l);\n                d.bar && d.xAxisID === n.id && a.chart.isDatasetVisible(l) && (o += s.data[e] < 0 ? s.data[e] : 0);\n              } else for (var u = 0; t > u; u++) {\n                var c = a.chart.data.datasets[u],\n                  h = a.chart.getDatasetMeta(u);\n                h.bar && h.xAxisID === n.id && a.chart.isDatasetVisible(u) && (o += c.data[e] > 0 ? c.data[e] : 0);\n              }\n              return n.getPixelForValue(o);\n            }\n            return n.getBasePixel();\n          },\n          getRuler: function (t) {\n            var e,\n              a = this,\n              i = a.getMeta(),\n              n = a.getScaleForId(i.yAxisID),\n              o = a.getBarCount();\n            e = \"category\" === n.options.type ? n.getPixelForTick(t + 1) - n.getPixelForTick(t) : n.width / n.ticks.length;\n            var r = e * n.options.categoryPercentage,\n              l = (e - e * n.options.categoryPercentage) / 2,\n              s = r / o;\n            if (n.ticks.length !== a.chart.data.labels.length) {\n              var d = n.ticks.length / a.chart.data.labels.length;\n              s *= d;\n            }\n            var u = s * n.options.barPercentage,\n              c = s - s * n.options.barPercentage;\n            return {\n              datasetCount: o,\n              tickHeight: e,\n              categoryHeight: r,\n              categorySpacing: l,\n              fullBarHeight: s,\n              barHeight: u,\n              barSpacing: c\n            };\n          },\n          calculateBarHeight: function (t) {\n            var e = this,\n              a = e.getScaleForId(e.getMeta().yAxisID),\n              i = e.getRuler(t);\n            return a.options.stacked ? i.categoryHeight : i.barHeight;\n          },\n          calculateBarX: function (t, e) {\n            var a = this,\n              i = a.getMeta(),\n              n = a.getScaleForId(i.xAxisID),\n              o = a.getDataset().data[t];\n            if (n.options.stacked) {\n              for (var r = 0, l = 0, s = 0; e > s; s++) {\n                var d = a.chart.data.datasets[s],\n                  u = a.chart.getDatasetMeta(s);\n                u.bar && u.xAxisID === n.id && a.chart.isDatasetVisible(s) && (d.data[t] < 0 ? l += d.data[t] || 0 : r += d.data[t] || 0);\n              }\n              return 0 > o ? n.getPixelForValue(l + o) : n.getPixelForValue(r + o);\n            }\n            return n.getPixelForValue(o);\n          },\n          calculateBarY: function (t, e) {\n            var a = this,\n              i = a.getMeta(),\n              n = a.getScaleForId(i.yAxisID),\n              o = a.getBarIndex(e),\n              r = a.getRuler(t),\n              l = n.getPixelForValue(null, t, e, a.chart.isCombo);\n            return l -= a.chart.isCombo ? r.tickHeight / 2 : 0, n.options.stacked ? l + r.categoryHeight / 2 + r.categorySpacing : l + r.barHeight / 2 + r.categorySpacing + r.barHeight * o + r.barSpacing / 2 + r.barSpacing * o;\n          }\n        });\n      };\n    }, {}],\n    16: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers;\n        t.defaults.bubble = {\n          hover: {\n            mode: \"single\"\n          },\n          scales: {\n            xAxes: [{\n              type: \"linear\",\n              position: \"bottom\",\n              id: \"x-axis-0\"\n            }],\n            yAxes: [{\n              type: \"linear\",\n              position: \"left\",\n              id: \"y-axis-0\"\n            }]\n          },\n          tooltips: {\n            callbacks: {\n              title: function (t, e) {\n                return \"\";\n              },\n              label: function (t, e) {\n                var a = e.datasets[t.datasetIndex].label || \"\",\n                  i = e.datasets[t.datasetIndex].data[t.index];\n                return a + \": (\" + i.x + \", \" + i.y + \", \" + i.r + \")\";\n              }\n            }\n          }\n        }, t.controllers.bubble = t.DatasetController.extend({\n          dataElementType: t.elements.Point,\n          update: function (t) {\n            var a = this,\n              i = a.getMeta(),\n              n = i.data;\n            e.each(n, function (e, i) {\n              a.updateElement(e, i, t);\n            });\n          },\n          updateElement: function (a, i, n) {\n            var o = this,\n              r = o.getMeta(),\n              l = o.getScaleForId(r.xAxisID),\n              s = o.getScaleForId(r.yAxisID),\n              d = a.custom || {},\n              u = o.getDataset(),\n              c = u.data[i],\n              h = o.chart.options.elements.point,\n              f = o.index;\n            e.extend(a, {\n              _xScale: l,\n              _yScale: s,\n              _datasetIndex: f,\n              _index: i,\n              _model: {\n                x: n ? l.getPixelForDecimal(.5) : l.getPixelForValue(c, i, f, o.chart.isCombo),\n                y: n ? s.getBasePixel() : s.getPixelForValue(c, i, f),\n                radius: n ? 0 : d.radius ? d.radius : o.getRadius(c),\n                hitRadius: d.hitRadius ? d.hitRadius : e.getValueAtIndexOrDefault(u.hitRadius, i, h.hitRadius)\n              }\n            }), t.DatasetController.prototype.removeHoverStyle.call(o, a, h);\n            var g = a._model;\n            g.skip = d.skip ? d.skip : isNaN(g.x) || isNaN(g.y), a.pivot();\n          },\n          getRadius: function (t) {\n            return t.r || this.chart.options.elements.point.radius;\n          },\n          setHoverStyle: function (a) {\n            var i = this;\n            t.DatasetController.prototype.setHoverStyle.call(i, a);\n            var n = i.chart.data.datasets[a._datasetIndex],\n              o = a._index,\n              r = a.custom || {},\n              l = a._model;\n            l.radius = r.hoverRadius ? r.hoverRadius : e.getValueAtIndexOrDefault(n.hoverRadius, o, i.chart.options.elements.point.hoverRadius) + i.getRadius(n.data[o]);\n          },\n          removeHoverStyle: function (e) {\n            var a = this;\n            t.DatasetController.prototype.removeHoverStyle.call(a, e, a.chart.options.elements.point);\n            var i = a.chart.data.datasets[e._datasetIndex].data[e._index],\n              n = e.custom || {},\n              o = e._model;\n            o.radius = n.radius ? n.radius : a.getRadius(i);\n          }\n        });\n      };\n    }, {}],\n    17: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers,\n          a = t.defaults;\n        a.doughnut = {\n          animation: {\n            animateRotate: !0,\n            animateScale: !1\n          },\n          aspectRatio: 1,\n          hover: {\n            mode: \"single\"\n          },\n          legendCallback: function (t) {\n            var e = [];\n            e.push('<ul class=\"' + t.id + '-legend\">');\n            var a = t.data,\n              i = a.datasets,\n              n = a.labels;\n            if (i.length) for (var o = 0; o < i[0].data.length; ++o) e.push('<li><span style=\"background-color:' + i[0].backgroundColor[o] + '\"></span>'), n[o] && e.push(n[o]), e.push(\"</li>\");\n            return e.push(\"</ul>\"), e.join(\"\");\n          },\n          legend: {\n            labels: {\n              generateLabels: function (t) {\n                var a = t.data;\n                return a.labels.length && a.datasets.length ? a.labels.map(function (i, n) {\n                  var o = t.getDatasetMeta(0),\n                    r = a.datasets[0],\n                    l = o.data[n],\n                    s = l.custom || {},\n                    d = e.getValueAtIndexOrDefault,\n                    u = t.options.elements.arc,\n                    c = s.backgroundColor ? s.backgroundColor : d(r.backgroundColor, n, u.backgroundColor),\n                    h = s.borderColor ? s.borderColor : d(r.borderColor, n, u.borderColor),\n                    f = s.borderWidth ? s.borderWidth : d(r.borderWidth, n, u.borderWidth);\n                  return {\n                    text: i,\n                    fillStyle: c,\n                    strokeStyle: h,\n                    lineWidth: f,\n                    hidden: isNaN(r.data[n]) || o.data[n].hidden,\n                    index: n\n                  };\n                }) : [];\n              }\n            },\n            onClick: function (t, e) {\n              var a,\n                i,\n                n,\n                o = e.index,\n                r = this.chart;\n              for (a = 0, i = (r.data.datasets || []).length; i > a; ++a) n = r.getDatasetMeta(a), n.data[o].hidden = !n.data[o].hidden;\n              r.update();\n            }\n          },\n          cutoutPercentage: 50,\n          rotation: Math.PI * -.5,\n          circumference: 2 * Math.PI,\n          tooltips: {\n            callbacks: {\n              title: function () {\n                return \"\";\n              },\n              label: function (t, e) {\n                return e.labels[t.index] + \": \" + e.datasets[t.datasetIndex].data[t.index];\n              }\n            }\n          }\n        }, a.pie = e.clone(a.doughnut), e.extend(a.pie, {\n          cutoutPercentage: 0\n        }), t.controllers.doughnut = t.controllers.pie = t.DatasetController.extend({\n          dataElementType: t.elements.Arc,\n          linkScales: e.noop,\n          getRingIndex: function (t) {\n            for (var e = 0, a = 0; t > a; ++a) this.chart.isDatasetVisible(a) && ++e;\n            return e;\n          },\n          update: function (t) {\n            var a = this,\n              i = a.chart,\n              n = i.chartArea,\n              o = i.options,\n              r = o.elements.arc,\n              l = n.right - n.left - r.borderWidth,\n              s = n.bottom - n.top - r.borderWidth,\n              d = Math.min(l, s),\n              u = {\n                x: 0,\n                y: 0\n              },\n              c = a.getMeta(),\n              h = o.cutoutPercentage,\n              f = o.circumference;\n            if (f < 2 * Math.PI) {\n              var g = o.rotation % (2 * Math.PI);\n              g += 2 * Math.PI * (g >= Math.PI ? -1 : g < -Math.PI ? 1 : 0);\n              var p = g + f,\n                m = {\n                  x: Math.cos(g),\n                  y: Math.sin(g)\n                },\n                b = {\n                  x: Math.cos(p),\n                  y: Math.sin(p)\n                },\n                v = 0 >= g && p >= 0 || g <= 2 * Math.PI && 2 * Math.PI <= p,\n                x = g <= .5 * Math.PI && .5 * Math.PI <= p || g <= 2.5 * Math.PI && 2.5 * Math.PI <= p,\n                y = g <= -Math.PI && -Math.PI <= p || g <= Math.PI && Math.PI <= p,\n                k = g <= .5 * -Math.PI && .5 * -Math.PI <= p || g <= 1.5 * Math.PI && 1.5 * Math.PI <= p,\n                S = h / 100,\n                w = {\n                  x: y ? -1 : Math.min(m.x * (m.x < 0 ? 1 : S), b.x * (b.x < 0 ? 1 : S)),\n                  y: k ? -1 : Math.min(m.y * (m.y < 0 ? 1 : S), b.y * (b.y < 0 ? 1 : S))\n                },\n                C = {\n                  x: v ? 1 : Math.max(m.x * (m.x > 0 ? 1 : S), b.x * (b.x > 0 ? 1 : S)),\n                  y: x ? 1 : Math.max(m.y * (m.y > 0 ? 1 : S), b.y * (b.y > 0 ? 1 : S))\n                },\n                M = {\n                  width: .5 * (C.x - w.x),\n                  height: .5 * (C.y - w.y)\n                };\n              d = Math.min(l / M.width, s / M.height), u = {\n                x: (C.x + w.x) * -.5,\n                y: (C.y + w.y) * -.5\n              };\n            }\n            i.outerRadius = Math.max(d / 2, 0), i.innerRadius = Math.max(h ? i.outerRadius / 100 * h : 1, 0), i.radiusLength = (i.outerRadius - i.innerRadius) / i.getVisibleDatasetCount(), i.offsetX = u.x * i.outerRadius, i.offsetY = u.y * i.outerRadius, c.total = a.calculateTotal(), a.outerRadius = i.outerRadius - i.radiusLength * a.getRingIndex(a.index), a.innerRadius = a.outerRadius - i.radiusLength, e.each(c.data, function (e, i) {\n              a.updateElement(e, i, t);\n            });\n          },\n          updateElement: function (t, a, i) {\n            var n = this,\n              o = n.chart,\n              r = o.chartArea,\n              l = o.options,\n              s = l.animation,\n              d = (l.elements.arc, (r.left + r.right) / 2),\n              u = (r.top + r.bottom) / 2,\n              c = l.rotation,\n              h = l.rotation,\n              f = n.getDataset(),\n              g = i && s.animateRotate ? 0 : t.hidden ? 0 : n.calculateCircumference(f.data[a]) * (l.circumference / (2 * Math.PI)),\n              p = i && s.animateScale ? 0 : n.innerRadius,\n              m = i && s.animateScale ? 0 : n.outerRadius,\n              b = (t.custom || {}, e.getValueAtIndexOrDefault);\n            e.extend(t, {\n              _datasetIndex: n.index,\n              _index: a,\n              _model: {\n                x: d + o.offsetX,\n                y: u + o.offsetY,\n                startAngle: c,\n                endAngle: h,\n                circumference: g,\n                outerRadius: m,\n                innerRadius: p,\n                label: b(f.label, a, o.data.labels[a])\n              }\n            });\n            var v = t._model;\n            this.removeHoverStyle(t), i && s.animateRotate || (0 === a ? v.startAngle = l.rotation : v.startAngle = n.getMeta().data[a - 1]._model.endAngle, v.endAngle = v.startAngle + v.circumference), t.pivot();\n          },\n          removeHoverStyle: function (e) {\n            t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc);\n          },\n          calculateTotal: function () {\n            var t,\n              a = this.getDataset(),\n              i = this.getMeta(),\n              n = 0;\n            return e.each(i.data, function (e, i) {\n              t = a.data[i], isNaN(t) || e.hidden || (n += Math.abs(t));\n            }), n;\n          },\n          calculateCircumference: function (t) {\n            var e = this.getMeta().total;\n            return e > 0 && !isNaN(t) ? 2 * Math.PI * (t / e) : 0;\n          }\n        });\n      };\n    }, {}],\n    18: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        function e(t, e) {\n          return a.getValueOrDefault(t.showLine, e.showLines);\n        }\n        var a = t.helpers;\n        t.defaults.line = {\n          showLines: !0,\n          hover: {\n            mode: \"label\"\n          },\n          scales: {\n            xAxes: [{\n              type: \"category\",\n              id: \"x-axis-0\"\n            }],\n            yAxes: [{\n              type: \"linear\",\n              id: \"y-axis-0\"\n            }]\n          }\n        }, t.controllers.line = t.DatasetController.extend({\n          datasetElementType: t.elements.Line,\n          dataElementType: t.elements.Point,\n          addElementAndReset: function (a) {\n            var i = this,\n              n = i.chart.options,\n              o = i.getMeta();\n            t.DatasetController.prototype.addElementAndReset.call(i, a), e(i.getDataset(), n) && 0 !== o.dataset._model.tension && i.updateBezierControlPoints();\n          },\n          update: function (t) {\n            var i,\n              n,\n              o,\n              r = this,\n              l = r.getMeta(),\n              s = l.dataset,\n              d = l.data || [],\n              u = r.chart.options,\n              c = u.elements.line,\n              h = r.getScaleForId(l.yAxisID),\n              f = r.getDataset(),\n              g = e(f, u);\n            for (g && (o = s.custom || {}, void 0 !== f.tension && void 0 === f.lineTension && (f.lineTension = f.tension), s._scale = h, s._datasetIndex = r.index, s._children = d, s._model = {\n              spanGaps: f.spanGaps ? f.spanGaps : !1,\n              tension: o.tension ? o.tension : a.getValueOrDefault(f.lineTension, c.tension),\n              backgroundColor: o.backgroundColor ? o.backgroundColor : f.backgroundColor || c.backgroundColor,\n              borderWidth: o.borderWidth ? o.borderWidth : f.borderWidth || c.borderWidth,\n              borderColor: o.borderColor ? o.borderColor : f.borderColor || c.borderColor,\n              borderCapStyle: o.borderCapStyle ? o.borderCapStyle : f.borderCapStyle || c.borderCapStyle,\n              borderDash: o.borderDash ? o.borderDash : f.borderDash || c.borderDash,\n              borderDashOffset: o.borderDashOffset ? o.borderDashOffset : f.borderDashOffset || c.borderDashOffset,\n              borderJoinStyle: o.borderJoinStyle ? o.borderJoinStyle : f.borderJoinStyle || c.borderJoinStyle,\n              fill: o.fill ? o.fill : void 0 !== f.fill ? f.fill : c.fill,\n              scaleTop: h.top,\n              scaleBottom: h.bottom,\n              scaleZero: h.getBasePixel()\n            }, s.pivot()), i = 0, n = d.length; n > i; ++i) r.updateElement(d[i], i, t);\n            for (g && 0 !== s._model.tension && r.updateBezierControlPoints(), i = 0, n = d.length; n > i; ++i) d[i].pivot();\n          },\n          getPointBackgroundColor: function (t, e) {\n            var i = this.chart.options.elements.point.backgroundColor,\n              n = this.getDataset(),\n              o = t.custom || {};\n            return o.backgroundColor ? i = o.backgroundColor : n.pointBackgroundColor ? i = a.getValueAtIndexOrDefault(n.pointBackgroundColor, e, i) : n.backgroundColor && (i = n.backgroundColor), i;\n          },\n          getPointBorderColor: function (t, e) {\n            var i = this.chart.options.elements.point.borderColor,\n              n = this.getDataset(),\n              o = t.custom || {};\n            return o.borderColor ? i = o.borderColor : n.pointBorderColor ? i = a.getValueAtIndexOrDefault(n.pointBorderColor, e, i) : n.borderColor && (i = n.borderColor), i;\n          },\n          getPointBorderWidth: function (t, e) {\n            var i = this.chart.options.elements.point.borderWidth,\n              n = this.getDataset(),\n              o = t.custom || {};\n            return o.borderWidth ? i = o.borderWidth : n.pointBorderWidth ? i = a.getValueAtIndexOrDefault(n.pointBorderWidth, e, i) : n.borderWidth && (i = n.borderWidth), i;\n          },\n          updateElement: function (t, e, i) {\n            var n,\n              o,\n              r = this,\n              l = r.getMeta(),\n              s = t.custom || {},\n              d = r.getDataset(),\n              u = r.index,\n              c = d.data[e],\n              h = r.getScaleForId(l.yAxisID),\n              f = r.getScaleForId(l.xAxisID),\n              g = r.chart.options.elements.point;\n            void 0 !== d.radius && void 0 === d.pointRadius && (d.pointRadius = d.radius), void 0 !== d.hitRadius && void 0 === d.pointHitRadius && (d.pointHitRadius = d.hitRadius), n = f.getPixelForValue(c, e, u, r.chart.isCombo), o = i ? h.getBasePixel() : r.calculatePointY(c, e, u, r.chart.isCombo), t._xScale = f, t._yScale = h, t._datasetIndex = u, t._index = e, t._model = {\n              x: n,\n              y: o,\n              skip: s.skip || isNaN(n) || isNaN(o),\n              radius: s.radius || a.getValueAtIndexOrDefault(d.pointRadius, e, g.radius),\n              pointStyle: s.pointStyle || a.getValueAtIndexOrDefault(d.pointStyle, e, g.pointStyle),\n              backgroundColor: r.getPointBackgroundColor(t, e),\n              borderColor: r.getPointBorderColor(t, e),\n              borderWidth: r.getPointBorderWidth(t, e),\n              tension: l.dataset._model ? l.dataset._model.tension : 0,\n              hitRadius: s.hitRadius || a.getValueAtIndexOrDefault(d.pointHitRadius, e, g.hitRadius)\n            };\n          },\n          calculatePointY: function (t, e, a, i) {\n            var n,\n              o,\n              r,\n              l = this,\n              s = l.chart,\n              d = l.getMeta(),\n              u = l.getScaleForId(d.yAxisID),\n              c = 0,\n              h = 0;\n            if (u.options.stacked) {\n              for (n = 0; a > n; n++) o = s.data.datasets[n], r = s.getDatasetMeta(n), \"line\" === r.type && s.isDatasetVisible(n) && (o.data[e] < 0 ? h += o.data[e] || 0 : c += o.data[e] || 0);\n              return 0 > t ? u.getPixelForValue(h + t) : u.getPixelForValue(c + t);\n            }\n            return u.getPixelForValue(t);\n          },\n          updateBezierControlPoints: function () {\n            var t,\n              e,\n              i,\n              n,\n              o,\n              r = this.getMeta(),\n              l = (this.chart.chartArea, r.data || []);\n            for (t = 0, e = l.length; e > t; ++t) i = l[t], n = i._model, o = a.splineCurve(a.previousItem(l, t)._model, n, a.nextItem(l, t)._model, r.dataset._model.tension), n.controlPointPreviousX = o.previous.x, n.controlPointPreviousY = o.previous.y, n.controlPointNextX = o.next.x, n.controlPointNextY = o.next.y;\n          },\n          draw: function (t) {\n            var a,\n              i,\n              n = this,\n              o = n.getMeta(),\n              r = o.data || [],\n              l = t || 1;\n            for (a = 0, i = r.length; i > a; ++a) r[a].transition(l);\n            for (e(n.getDataset(), n.chart.options) && o.dataset.transition(l).draw(), a = 0, i = r.length; i > a; ++a) r[a].draw();\n          },\n          setHoverStyle: function (t) {\n            var e = this.chart.data.datasets[t._datasetIndex],\n              i = t._index,\n              n = t.custom || {},\n              o = t._model;\n            o.radius = n.hoverRadius || a.getValueAtIndexOrDefault(e.pointHoverRadius, i, this.chart.options.elements.point.hoverRadius), o.backgroundColor = n.hoverBackgroundColor || a.getValueAtIndexOrDefault(e.pointHoverBackgroundColor, i, a.getHoverColor(o.backgroundColor)), o.borderColor = n.hoverBorderColor || a.getValueAtIndexOrDefault(e.pointHoverBorderColor, i, a.getHoverColor(o.borderColor)), o.borderWidth = n.hoverBorderWidth || a.getValueAtIndexOrDefault(e.pointHoverBorderWidth, i, o.borderWidth);\n          },\n          removeHoverStyle: function (t) {\n            var e = this,\n              i = e.chart.data.datasets[t._datasetIndex],\n              n = t._index,\n              o = t.custom || {},\n              r = t._model;\n            void 0 !== i.radius && void 0 === i.pointRadius && (i.pointRadius = i.radius), r.radius = o.radius || a.getValueAtIndexOrDefault(i.pointRadius, n, e.chart.options.elements.point.radius), r.backgroundColor = e.getPointBackgroundColor(t, n), r.borderColor = e.getPointBorderColor(t, n), r.borderWidth = e.getPointBorderWidth(t, n);\n          }\n        });\n      };\n    }, {}],\n    19: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers;\n        t.defaults.polarArea = {\n          scale: {\n            type: \"radialLinear\",\n            lineArc: !0\n          },\n          animation: {\n            animateRotate: !0,\n            animateScale: !0\n          },\n          aspectRatio: 1,\n          legendCallback: function (t) {\n            var e = [];\n            e.push('<ul class=\"' + t.id + '-legend\">');\n            var a = t.data,\n              i = a.datasets,\n              n = a.labels;\n            if (i.length) for (var o = 0; o < i[0].data.length; ++o) e.push('<li><span style=\"background-color:' + i[0].backgroundColor[o] + '\">'), n[o] && e.push(n[o]), e.push(\"</span></li>\");\n            return e.push(\"</ul>\"), e.join(\"\");\n          },\n          legend: {\n            labels: {\n              generateLabels: function (t) {\n                var a = t.data;\n                return a.labels.length && a.datasets.length ? a.labels.map(function (i, n) {\n                  var o = t.getDatasetMeta(0),\n                    r = a.datasets[0],\n                    l = o.data[n],\n                    s = l.custom || {},\n                    d = e.getValueAtIndexOrDefault,\n                    u = t.options.elements.arc,\n                    c = s.backgroundColor ? s.backgroundColor : d(r.backgroundColor, n, u.backgroundColor),\n                    h = s.borderColor ? s.borderColor : d(r.borderColor, n, u.borderColor),\n                    f = s.borderWidth ? s.borderWidth : d(r.borderWidth, n, u.borderWidth);\n                  return {\n                    text: i,\n                    fillStyle: c,\n                    strokeStyle: h,\n                    lineWidth: f,\n                    hidden: isNaN(r.data[n]) || o.data[n].hidden,\n                    index: n\n                  };\n                }) : [];\n              }\n            },\n            onClick: function (t, e) {\n              var a,\n                i,\n                n,\n                o = e.index,\n                r = this.chart;\n              for (a = 0, i = (r.data.datasets || []).length; i > a; ++a) n = r.getDatasetMeta(a), n.data[o].hidden = !n.data[o].hidden;\n              r.update();\n            }\n          },\n          tooltips: {\n            callbacks: {\n              title: function () {\n                return \"\";\n              },\n              label: function (t, e) {\n                return e.labels[t.index] + \": \" + t.yLabel;\n              }\n            }\n          }\n        }, t.controllers.polarArea = t.DatasetController.extend({\n          dataElementType: t.elements.Arc,\n          linkScales: e.noop,\n          update: function (t) {\n            var a = this,\n              i = a.chart,\n              n = i.chartArea,\n              o = a.getMeta(),\n              r = i.options,\n              l = r.elements.arc,\n              s = Math.min(n.right - n.left, n.bottom - n.top);\n            i.outerRadius = Math.max((s - l.borderWidth / 2) / 2, 0), i.innerRadius = Math.max(r.cutoutPercentage ? i.outerRadius / 100 * r.cutoutPercentage : 1, 0), i.radiusLength = (i.outerRadius - i.innerRadius) / i.getVisibleDatasetCount(), a.outerRadius = i.outerRadius - i.radiusLength * a.index, a.innerRadius = a.outerRadius - i.radiusLength, o.count = a.countVisibleElements(), e.each(o.data, function (e, i) {\n              a.updateElement(e, i, t);\n            });\n          },\n          updateElement: function (t, a, i) {\n            for (var n = this, o = n.chart, r = o.chartArea, l = n.getDataset(), s = o.options, d = s.animation, u = (s.elements.arc, t.custom || {}, o.scale), c = e.getValueAtIndexOrDefault, h = o.data.labels, f = n.calculateCircumference(l.data[a]), g = (r.left + r.right) / 2, p = (r.top + r.bottom) / 2, m = 0, b = n.getMeta(), v = 0; a > v; ++v) isNaN(l.data[v]) || b.data[v].hidden || ++m;\n            var x = -.5 * Math.PI,\n              y = t.hidden ? 0 : u.getDistanceFromCenterForValue(l.data[a]),\n              k = x + f * m,\n              S = k + (t.hidden ? 0 : f),\n              w = d.animateScale ? 0 : u.getDistanceFromCenterForValue(l.data[a]);\n            e.extend(t, {\n              _datasetIndex: n.index,\n              _index: a,\n              _scale: u,\n              _model: {\n                x: g,\n                y: p,\n                innerRadius: 0,\n                outerRadius: i ? w : y,\n                startAngle: i && d.animateRotate ? x : k,\n                endAngle: i && d.animateRotate ? x : S,\n                label: c(h, a, h[a])\n              }\n            }), n.removeHoverStyle(t), t.pivot();\n          },\n          removeHoverStyle: function (e) {\n            t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc);\n          },\n          countVisibleElements: function () {\n            var t = this.getDataset(),\n              a = this.getMeta(),\n              i = 0;\n            return e.each(a.data, function (e, a) {\n              isNaN(t.data[a]) || e.hidden || i++;\n            }), i;\n          },\n          calculateCircumference: function (t) {\n            var e = this.getMeta().count;\n            return e > 0 && !isNaN(t) ? 2 * Math.PI / e : 0;\n          }\n        });\n      };\n    }, {}],\n    20: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers;\n        t.defaults.radar = {\n          scale: {\n            type: \"radialLinear\"\n          },\n          elements: {\n            line: {\n              tension: 0\n            }\n          }\n        }, t.controllers.radar = t.DatasetController.extend({\n          datasetElementType: t.elements.Line,\n          dataElementType: t.elements.Point,\n          linkScales: e.noop,\n          addElementAndReset: function (e) {\n            t.DatasetController.prototype.addElementAndReset.call(this, e), this.updateBezierControlPoints();\n          },\n          update: function (t) {\n            var a = this,\n              i = a.getMeta(),\n              n = i.dataset,\n              o = i.data,\n              r = n.custom || {},\n              l = a.getDataset(),\n              s = a.chart.options.elements.line,\n              d = a.chart.scale;\n            void 0 !== l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), e.extend(i.dataset, {\n              _datasetIndex: a.index,\n              _children: o,\n              _loop: !0,\n              _model: {\n                tension: r.tension ? r.tension : e.getValueOrDefault(l.lineTension, s.tension),\n                backgroundColor: r.backgroundColor ? r.backgroundColor : l.backgroundColor || s.backgroundColor,\n                borderWidth: r.borderWidth ? r.borderWidth : l.borderWidth || s.borderWidth,\n                borderColor: r.borderColor ? r.borderColor : l.borderColor || s.borderColor,\n                fill: r.fill ? r.fill : void 0 !== l.fill ? l.fill : s.fill,\n                borderCapStyle: r.borderCapStyle ? r.borderCapStyle : l.borderCapStyle || s.borderCapStyle,\n                borderDash: r.borderDash ? r.borderDash : l.borderDash || s.borderDash,\n                borderDashOffset: r.borderDashOffset ? r.borderDashOffset : l.borderDashOffset || s.borderDashOffset,\n                borderJoinStyle: r.borderJoinStyle ? r.borderJoinStyle : l.borderJoinStyle || s.borderJoinStyle,\n                scaleTop: d.top,\n                scaleBottom: d.bottom,\n                scaleZero: d.getBasePosition()\n              }\n            }), i.dataset.pivot(), e.each(o, function (e, i) {\n              a.updateElement(e, i, t);\n            }, a), a.updateBezierControlPoints();\n          },\n          updateElement: function (t, a, i) {\n            var n = this,\n              o = t.custom || {},\n              r = n.getDataset(),\n              l = n.chart.scale,\n              s = n.chart.options.elements.point,\n              d = l.getPointPositionForValue(a, r.data[a]);\n            e.extend(t, {\n              _datasetIndex: n.index,\n              _index: a,\n              _scale: l,\n              _model: {\n                x: i ? l.xCenter : d.x,\n                y: i ? l.yCenter : d.y,\n                tension: o.tension ? o.tension : e.getValueOrDefault(r.tension, n.chart.options.elements.line.tension),\n                radius: o.radius ? o.radius : e.getValueAtIndexOrDefault(r.pointRadius, a, s.radius),\n                backgroundColor: o.backgroundColor ? o.backgroundColor : e.getValueAtIndexOrDefault(r.pointBackgroundColor, a, s.backgroundColor),\n                borderColor: o.borderColor ? o.borderColor : e.getValueAtIndexOrDefault(r.pointBorderColor, a, s.borderColor),\n                borderWidth: o.borderWidth ? o.borderWidth : e.getValueAtIndexOrDefault(r.pointBorderWidth, a, s.borderWidth),\n                pointStyle: o.pointStyle ? o.pointStyle : e.getValueAtIndexOrDefault(r.pointStyle, a, s.pointStyle),\n                hitRadius: o.hitRadius ? o.hitRadius : e.getValueAtIndexOrDefault(r.hitRadius, a, s.hitRadius)\n              }\n            }), t._model.skip = o.skip ? o.skip : isNaN(t._model.x) || isNaN(t._model.y);\n          },\n          updateBezierControlPoints: function () {\n            var t = this.chart.chartArea,\n              a = this.getMeta();\n            e.each(a.data, function (i, n) {\n              var o = i._model,\n                r = e.splineCurve(e.previousItem(a.data, n, !0)._model, o, e.nextItem(a.data, n, !0)._model, o.tension);\n              o.controlPointPreviousX = Math.max(Math.min(r.previous.x, t.right), t.left), o.controlPointPreviousY = Math.max(Math.min(r.previous.y, t.bottom), t.top), o.controlPointNextX = Math.max(Math.min(r.next.x, t.right), t.left), o.controlPointNextY = Math.max(Math.min(r.next.y, t.bottom), t.top), i.pivot();\n            });\n          },\n          draw: function (t) {\n            var a = this.getMeta(),\n              i = t || 1;\n            e.each(a.data, function (t, e) {\n              t.transition(i);\n            }), a.dataset.transition(i).draw(), e.each(a.data, function (t) {\n              t.draw();\n            });\n          },\n          setHoverStyle: function (t) {\n            var a = this.chart.data.datasets[t._datasetIndex],\n              i = t.custom || {},\n              n = t._index,\n              o = t._model;\n            o.radius = i.hoverRadius ? i.hoverRadius : e.getValueAtIndexOrDefault(a.pointHoverRadius, n, this.chart.options.elements.point.hoverRadius), o.backgroundColor = i.hoverBackgroundColor ? i.hoverBackgroundColor : e.getValueAtIndexOrDefault(a.pointHoverBackgroundColor, n, e.getHoverColor(o.backgroundColor)), o.borderColor = i.hoverBorderColor ? i.hoverBorderColor : e.getValueAtIndexOrDefault(a.pointHoverBorderColor, n, e.getHoverColor(o.borderColor)), o.borderWidth = i.hoverBorderWidth ? i.hoverBorderWidth : e.getValueAtIndexOrDefault(a.pointHoverBorderWidth, n, o.borderWidth);\n          },\n          removeHoverStyle: function (t) {\n            var a = this.chart.data.datasets[t._datasetIndex],\n              i = t.custom || {},\n              n = t._index,\n              o = t._model,\n              r = this.chart.options.elements.point;\n            o.radius = i.radius ? i.radius : e.getValueAtIndexOrDefault(a.radius, n, r.radius), o.backgroundColor = i.backgroundColor ? i.backgroundColor : e.getValueAtIndexOrDefault(a.pointBackgroundColor, n, r.backgroundColor), o.borderColor = i.borderColor ? i.borderColor : e.getValueAtIndexOrDefault(a.pointBorderColor, n, r.borderColor), o.borderWidth = i.borderWidth ? i.borderWidth : e.getValueAtIndexOrDefault(a.pointBorderWidth, n, r.borderWidth);\n          }\n        });\n      };\n    }, {}],\n    21: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers;\n        t.defaults.global.animation = {\n          duration: 1e3,\n          easing: \"easeOutQuart\",\n          onProgress: e.noop,\n          onComplete: e.noop\n        }, t.Animation = t.Element.extend({\n          currentStep: null,\n          numSteps: 60,\n          easing: \"\",\n          render: null,\n          onAnimationProgress: null,\n          onAnimationComplete: null\n        }), t.animationService = {\n          frameDuration: 17,\n          animations: [],\n          dropFrames: 0,\n          request: null,\n          addAnimation: function (t, e, a, i) {\n            var n = this;\n            i || (t.animating = !0);\n            for (var o = 0; o < n.animations.length; ++o) if (n.animations[o].chartInstance === t) return void (n.animations[o].animationObject = e);\n            n.animations.push({\n              chartInstance: t,\n              animationObject: e\n            }), 1 === n.animations.length && n.requestAnimationFrame();\n          },\n          cancelAnimation: function (t) {\n            var a = e.findIndex(this.animations, function (e) {\n              return e.chartInstance === t;\n            });\n            -1 !== a && (this.animations.splice(a, 1), t.animating = !1);\n          },\n          requestAnimationFrame: function () {\n            var t = this;\n            null === t.request && (t.request = e.requestAnimFrame.call(window, function () {\n              t.request = null, t.startDigest();\n            }));\n          },\n          startDigest: function () {\n            var t = this,\n              e = Date.now(),\n              a = 0;\n            t.dropFrames > 1 && (a = Math.floor(t.dropFrames), t.dropFrames = t.dropFrames % 1);\n            for (var i = 0; i < t.animations.length;) null === t.animations[i].animationObject.currentStep && (t.animations[i].animationObject.currentStep = 0), t.animations[i].animationObject.currentStep += 1 + a, t.animations[i].animationObject.currentStep > t.animations[i].animationObject.numSteps && (t.animations[i].animationObject.currentStep = t.animations[i].animationObject.numSteps), t.animations[i].animationObject.render(t.animations[i].chartInstance, t.animations[i].animationObject), t.animations[i].animationObject.onAnimationProgress && t.animations[i].animationObject.onAnimationProgress.call && t.animations[i].animationObject.onAnimationProgress.call(t.animations[i].chartInstance, t.animations[i]), t.animations[i].animationObject.currentStep === t.animations[i].animationObject.numSteps ? (t.animations[i].animationObject.onAnimationComplete && t.animations[i].animationObject.onAnimationComplete.call && t.animations[i].animationObject.onAnimationComplete.call(t.animations[i].chartInstance, t.animations[i]), t.animations[i].chartInstance.animating = !1, t.animations.splice(i, 1)) : ++i;\n            var n = Date.now(),\n              o = (n - e) / t.frameDuration;\n            t.dropFrames += o, t.animations.length > 0 && t.requestAnimationFrame();\n          }\n        };\n      };\n    }, {}],\n    22: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers;\n        t.types = {}, t.instances = {}, t.controllers = {}, t.Controller = function (a) {\n          return this.chart = a, this.config = a.config, this.options = this.config.options = e.configMerge(t.defaults.global, t.defaults[this.config.type], this.config.options || {}), this.id = e.uid(), Object.defineProperty(this, \"data\", {\n            get: function () {\n              return this.config.data;\n            }\n          }), t.instances[this.id] = this, this.options.responsive && this.resize(!0), this.initialize(), this;\n        }, e.extend(t.Controller.prototype, {\n          initialize: function () {\n            var e = this;\n            return t.plugins.notify(\"beforeInit\", [e]), e.bindEvents(), e.ensureScalesHaveIDs(), e.buildOrUpdateControllers(), e.buildScales(), e.updateLayout(), e.resetElements(), e.initToolTip(), e.update(), t.plugins.notify(\"afterInit\", [e]), e;\n          },\n          clear: function () {\n            return e.clear(this.chart), this;\n          },\n          stop: function () {\n            return t.animationService.cancelAnimation(this), this;\n          },\n          resize: function (a) {\n            var i = this,\n              n = i.chart,\n              o = n.canvas,\n              r = e.getMaximumWidth(o),\n              l = n.aspectRatio,\n              s = i.options.maintainAspectRatio && isNaN(l) === !1 && isFinite(l) && 0 !== l ? r / l : e.getMaximumHeight(o),\n              d = n.width !== r || n.height !== s;\n            if (!d) return i;\n            o.width = n.width = r, o.height = n.height = s, e.retinaScale(n);\n            var u = {\n              width: r,\n              height: s\n            };\n            return t.plugins.notify(\"resize\", [i, u]), i.options.onResize && i.options.onResize(i, u), a || (i.stop(), i.update(i.options.responsiveAnimationDuration)), i;\n          },\n          ensureScalesHaveIDs: function () {\n            var t = this.options,\n              a = t.scales || {},\n              i = t.scale;\n            e.each(a.xAxes, function (t, e) {\n              t.id = t.id || \"x-axis-\" + e;\n            }), e.each(a.yAxes, function (t, e) {\n              t.id = t.id || \"y-axis-\" + e;\n            }), i && (i.id = i.id || \"scale\");\n          },\n          buildScales: function () {\n            var a = this,\n              i = a.options,\n              n = a.scales = {},\n              o = [];\n            i.scales && (o = o.concat((i.scales.xAxes || []).map(function (t) {\n              return {\n                options: t,\n                dtype: \"category\"\n              };\n            }), (i.scales.yAxes || []).map(function (t) {\n              return {\n                options: t,\n                dtype: \"linear\"\n              };\n            }))), i.scale && o.push({\n              options: i.scale,\n              dtype: \"radialLinear\",\n              isDefault: !0\n            }), e.each(o, function (i, o) {\n              var r = i.options,\n                l = e.getValueOrDefault(r.type, i.dtype),\n                s = t.scaleService.getScaleConstructor(l);\n              if (s) {\n                var d = new s({\n                  id: r.id,\n                  options: r,\n                  ctx: a.chart.ctx,\n                  chart: a\n                });\n                n[d.id] = d, i.isDefault && (a.scale = d);\n              }\n            }), t.scaleService.addScalesToLayout(this);\n          },\n          updateLayout: function () {\n            t.layoutService.update(this, this.chart.width, this.chart.height);\n          },\n          buildOrUpdateControllers: function () {\n            var a = this,\n              i = [],\n              n = [];\n            if (e.each(a.data.datasets, function (e, o) {\n              var r = a.getDatasetMeta(o);\n              r.type || (r.type = e.type || a.config.type), i.push(r.type), r.controller ? r.controller.updateIndex(o) : (r.controller = new t.controllers[r.type](a, o), n.push(r.controller));\n            }, a), i.length > 1) for (var o = 1; o < i.length; o++) if (i[o] !== i[o - 1]) {\n              a.isCombo = !0;\n              break;\n            }\n            return n;\n          },\n          resetElements: function () {\n            var t = this;\n            e.each(t.data.datasets, function (e, a) {\n              t.getDatasetMeta(a).controller.reset();\n            }, t);\n          },\n          update: function (a, i) {\n            var n = this;\n            t.plugins.notify(\"beforeUpdate\", [n]), n.tooltip._data = n.data;\n            var o = n.buildOrUpdateControllers();\n            e.each(n.data.datasets, function (t, e) {\n              n.getDatasetMeta(e).controller.buildOrUpdateElements();\n            }, n), t.layoutService.update(n, n.chart.width, n.chart.height), t.plugins.notify(\"afterScaleUpdate\", [n]), e.each(o, function (t) {\n              t.reset();\n            }), n.updateDatasets(), t.plugins.notify(\"afterUpdate\", [n]), n.render(a, i);\n          },\n          updateDatasets: function () {\n            var e,\n              a,\n              i = this;\n            if (t.plugins.notify(\"beforeDatasetsUpdate\", [i])) {\n              for (e = 0, a = i.data.datasets.length; a > e; ++e) i.getDatasetMeta(e).controller.update();\n              t.plugins.notify(\"afterDatasetsUpdate\", [i]);\n            }\n          },\n          render: function (a, i) {\n            var n = this;\n            t.plugins.notify(\"beforeRender\", [n]);\n            var o = n.options.animation;\n            if (o && (\"undefined\" != typeof a && 0 !== a || \"undefined\" == typeof a && 0 !== o.duration)) {\n              var r = new t.Animation();\n              r.numSteps = (a || o.duration) / 16.66, r.easing = o.easing, r.render = function (t, a) {\n                var i = e.easingEffects[a.easing],\n                  n = a.currentStep / a.numSteps,\n                  o = i(n);\n                t.draw(o, n, a.currentStep);\n              }, r.onAnimationProgress = o.onProgress, r.onAnimationComplete = o.onComplete, t.animationService.addAnimation(n, r, a, i);\n            } else n.draw(), o && o.onComplete && o.onComplete.call && o.onComplete.call(n);\n            return n;\n          },\n          draw: function (a) {\n            var i = this,\n              n = a || 1;\n            i.clear(), t.plugins.notify(\"beforeDraw\", [i, n]), e.each(i.boxes, function (t) {\n              t.draw(i.chartArea);\n            }, i), i.scale && i.scale.draw(), t.plugins.notify(\"beforeDatasetsDraw\", [i, n]), e.each(i.data.datasets, function (t, e) {\n              i.isDatasetVisible(e) && i.getDatasetMeta(e).controller.draw(a);\n            }, i, !0), t.plugins.notify(\"afterDatasetsDraw\", [i, n]), i.tooltip.transition(n).draw(), t.plugins.notify(\"afterDraw\", [i, n]);\n          },\n          getElementAtEvent: function (t) {\n            var a = this,\n              i = e.getRelativePosition(t, a.chart),\n              n = [];\n            return e.each(a.data.datasets, function (t, o) {\n              if (a.isDatasetVisible(o)) {\n                var r = a.getDatasetMeta(o);\n                e.each(r.data, function (t, e) {\n                  return t.inRange(i.x, i.y) ? (n.push(t), n) : void 0;\n                });\n              }\n            }), n;\n          },\n          getElementsAtEvent: function (t) {\n            var a = this,\n              i = e.getRelativePosition(t, a.chart),\n              n = [],\n              o = function () {\n                if (a.data.datasets) for (var t = 0; t < a.data.datasets.length; t++) {\n                  var e = a.getDatasetMeta(t);\n                  if (a.isDatasetVisible(t)) for (var n = 0; n < e.data.length; n++) if (e.data[n].inRange(i.x, i.y)) return e.data[n];\n                }\n              }.call(a);\n            return o ? (e.each(a.data.datasets, function (t, e) {\n              if (a.isDatasetVisible(e)) {\n                var i = a.getDatasetMeta(e);\n                n.push(i.data[o._index]);\n              }\n            }, a), n) : n;\n          },\n          getElementsAtEventForMode: function (t, e) {\n            var a = this;\n            switch (e) {\n              case \"single\":\n                return a.getElementAtEvent(t);\n              case \"label\":\n                return a.getElementsAtEvent(t);\n              case \"dataset\":\n                return a.getDatasetAtEvent(t);\n              default:\n                return t;\n            }\n          },\n          getDatasetAtEvent: function (t) {\n            var e = this.getElementAtEvent(t);\n            return e.length > 0 && (e = this.getDatasetMeta(e[0]._datasetIndex).data), e;\n          },\n          getDatasetMeta: function (t) {\n            var e = this,\n              a = e.data.datasets[t];\n            a._meta || (a._meta = {});\n            var i = a._meta[e.id];\n            return i || (i = a._meta[e.id] = {\n              type: null,\n              data: [],\n              dataset: null,\n              controller: null,\n              hidden: null,\n              xAxisID: null,\n              yAxisID: null\n            }), i;\n          },\n          getVisibleDatasetCount: function () {\n            for (var t = 0, e = 0, a = this.data.datasets.length; a > e; ++e) this.isDatasetVisible(e) && t++;\n            return t;\n          },\n          isDatasetVisible: function (t) {\n            var e = this.getDatasetMeta(t);\n            return \"boolean\" == typeof e.hidden ? !e.hidden : !this.data.datasets[t].hidden;\n          },\n          generateLegend: function () {\n            return this.options.legendCallback(this);\n          },\n          destroy: function () {\n            var a = this;\n            a.stop(), a.clear(), e.unbindEvents(a, a.events), e.removeResizeListener(a.chart.canvas.parentNode);\n            var i = a.chart.canvas;\n            i.width = a.chart.width, i.height = a.chart.height, void 0 !== a.chart.originalDevicePixelRatio && a.chart.ctx.scale(1 / a.chart.originalDevicePixelRatio, 1 / a.chart.originalDevicePixelRatio), i.style.width = a.chart.originalCanvasStyleWidth, i.style.height = a.chart.originalCanvasStyleHeight, t.plugins.notify(\"destroy\", [a]), delete t.instances[a.id];\n          },\n          toBase64Image: function () {\n            return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);\n          },\n          initToolTip: function () {\n            var e = this;\n            e.tooltip = new t.Tooltip({\n              _chart: e.chart,\n              _chartInstance: e,\n              _data: e.data,\n              _options: e.options.tooltips\n            }, e);\n          },\n          bindEvents: function () {\n            var t = this;\n            e.bindEvents(t, t.options.events, function (e) {\n              t.eventHandler(e);\n            });\n          },\n          updateHoverStyle: function (t, e, a) {\n            var i,\n              n,\n              o,\n              r = a ? \"setHoverStyle\" : \"removeHoverStyle\";\n            switch (e) {\n              case \"single\":\n                t = [t[0]];\n                break;\n              case \"label\":\n              case \"dataset\":\n                break;\n              default:\n                return;\n            }\n            for (n = 0, o = t.length; o > n; ++n) i = t[n], i && this.getDatasetMeta(i._datasetIndex).controller[r](i);\n          },\n          eventHandler: function (t) {\n            var a = this,\n              i = a.tooltip,\n              n = a.options || {},\n              o = n.hover,\n              r = n.tooltips;\n            return a.lastActive = a.lastActive || [], a.lastTooltipActive = a.lastTooltipActive || [], \"mouseout\" === t.type ? (a.active = [], a.tooltipActive = []) : (a.active = a.getElementsAtEventForMode(t, o.mode), a.tooltipActive = a.getElementsAtEventForMode(t, r.mode)), o.onHover && o.onHover.call(a, a.active), (\"mouseup\" === t.type || \"click\" === t.type) && (n.onClick && n.onClick.call(a, t, a.active), a.legend && a.legend.handleEvent && a.legend.handleEvent(t)), a.lastActive.length && a.updateHoverStyle(a.lastActive, o.mode, !1), a.active.length && o.mode && a.updateHoverStyle(a.active, o.mode, !0), (r.enabled || r.custom) && (i.initialize(), i._active = a.tooltipActive, i.update(!0)), i.pivot(), a.animating || e.arrayEquals(a.active, a.lastActive) && e.arrayEquals(a.tooltipActive, a.lastTooltipActive) || (a.stop(), (r.enabled || r.custom) && i.update(!0), a.render(o.animationDuration, !0)), a.lastActive = a.active, a.lastTooltipActive = a.tooltipActive, a;\n          }\n        });\n      };\n    }, {}],\n    23: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers,\n          a = e.noop;\n        t.DatasetController = function (t, e) {\n          this.initialize.call(this, t, e);\n        }, e.extend(t.DatasetController.prototype, {\n          datasetElementType: null,\n          dataElementType: null,\n          initialize: function (t, e) {\n            var a = this;\n            a.chart = t, a.index = e, a.linkScales(), a.addElements();\n          },\n          updateIndex: function (t) {\n            this.index = t;\n          },\n          linkScales: function () {\n            var t = this,\n              e = t.getMeta(),\n              a = t.getDataset();\n            null === e.xAxisID && (e.xAxisID = a.xAxisID || t.chart.options.scales.xAxes[0].id), null === e.yAxisID && (e.yAxisID = a.yAxisID || t.chart.options.scales.yAxes[0].id);\n          },\n          getDataset: function () {\n            return this.chart.data.datasets[this.index];\n          },\n          getMeta: function () {\n            return this.chart.getDatasetMeta(this.index);\n          },\n          getScaleForId: function (t) {\n            return this.chart.scales[t];\n          },\n          reset: function () {\n            this.update(!0);\n          },\n          createMetaDataset: function () {\n            var t = this,\n              e = t.datasetElementType;\n            return e && new e({\n              _chart: t.chart.chart,\n              _datasetIndex: t.index\n            });\n          },\n          createMetaData: function (t) {\n            var e = this,\n              a = e.dataElementType;\n            return a && new a({\n              _chart: e.chart.chart,\n              _datasetIndex: e.index,\n              _index: t\n            });\n          },\n          addElements: function () {\n            var t,\n              e,\n              a = this,\n              i = a.getMeta(),\n              n = a.getDataset().data || [],\n              o = i.data;\n            for (t = 0, e = n.length; e > t; ++t) o[t] = o[t] || a.createMetaData(i, t);\n            i.dataset = i.dataset || a.createMetaDataset();\n          },\n          addElementAndReset: function (t) {\n            var e = this,\n              a = e.createMetaData(t);\n            e.getMeta().data.splice(t, 0, a), e.updateElement(a, t, !0);\n          },\n          buildOrUpdateElements: function () {\n            var t = this.getMeta(),\n              e = t.data,\n              a = this.getDataset().data.length,\n              i = e.length;\n            if (i > a) e.splice(a, i - a);else if (a > i) for (var n = i; a > n; ++n) this.addElementAndReset(n);\n          },\n          update: a,\n          draw: function (t) {\n            var a = t || 1;\n            e.each(this.getMeta().data, function (t, e) {\n              t.transition(a).draw();\n            });\n          },\n          removeHoverStyle: function (t, a) {\n            var i = this.chart.data.datasets[t._datasetIndex],\n              n = t._index,\n              o = t.custom || {},\n              r = e.getValueAtIndexOrDefault,\n              l = (e.color, t._model);\n            l.backgroundColor = o.backgroundColor ? o.backgroundColor : r(i.backgroundColor, n, a.backgroundColor), l.borderColor = o.borderColor ? o.borderColor : r(i.borderColor, n, a.borderColor), l.borderWidth = o.borderWidth ? o.borderWidth : r(i.borderWidth, n, a.borderWidth);\n          },\n          setHoverStyle: function (t) {\n            var a = this.chart.data.datasets[t._datasetIndex],\n              i = t._index,\n              n = t.custom || {},\n              o = e.getValueAtIndexOrDefault,\n              r = (e.color, e.getHoverColor),\n              l = t._model;\n            l.backgroundColor = n.hoverBackgroundColor ? n.hoverBackgroundColor : o(a.hoverBackgroundColor, i, r(l.backgroundColor)), l.borderColor = n.hoverBorderColor ? n.hoverBorderColor : o(a.hoverBorderColor, i, r(l.borderColor)), l.borderWidth = n.hoverBorderWidth ? n.hoverBorderWidth : o(a.hoverBorderWidth, i, l.borderWidth);\n          }\n        }), t.DatasetController.extend = e.inherits;\n      };\n    }, {}],\n    24: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers;\n        t.elements = {}, t.Element = function (t) {\n          e.extend(this, t), this.initialize.apply(this, arguments);\n        }, e.extend(t.Element.prototype, {\n          initialize: function () {\n            this.hidden = !1;\n          },\n          pivot: function () {\n            var t = this;\n            return t._view || (t._view = e.clone(t._model)), t._start = e.clone(t._view), t;\n          },\n          transition: function (t) {\n            var a = this;\n            return a._view || (a._view = e.clone(a._model)), 1 === t ? (a._view = a._model, a._start = null, a) : (a._start || a.pivot(), e.each(a._model, function (i, n) {\n              if (\"_\" === n[0]) ;else if (a._view.hasOwnProperty(n)) {\n                if (i === a._view[n]) ;else if (\"string\" == typeof i) try {\n                  var o = e.color(a._model[n]).mix(e.color(a._start[n]), t);\n                  a._view[n] = o.rgbString();\n                } catch (r) {\n                  a._view[n] = i;\n                } else if (\"number\" == typeof i) {\n                  var l = void 0 !== a._start[n] && isNaN(a._start[n]) === !1 ? a._start[n] : 0;\n                  a._view[n] = (a._model[n] - l) * t + l;\n                } else a._view[n] = i;\n              } else \"number\" != typeof i || isNaN(a._view[n]) ? a._view[n] = i : a._view[n] = i * t;\n            }, a), a);\n          },\n          tooltipPosition: function () {\n            return {\n              x: this._model.x,\n              y: this._model.y\n            };\n          },\n          hasValue: function () {\n            return e.isNumber(this._model.x) && e.isNumber(this._model.y);\n          }\n        }), t.Element.extend = e.inherits;\n      };\n    }, {}],\n    25: [function (t, e, a) {\n      \"use strict\";\n\n      var i = t(3);\n      e.exports = function (t) {\n        function e(t, e, a) {\n          var i;\n          return \"string\" == typeof t ? (i = parseInt(t, 10), -1 != t.indexOf(\"%\") && (i = i / 100 * e.parentNode[a])) : i = t, i;\n        }\n        function a(t) {\n          return void 0 !== t && null !== t && \"none\" !== t;\n        }\n        function n(t, i, n) {\n          var o = document.defaultView,\n            r = t.parentNode,\n            l = o.getComputedStyle(t)[i],\n            s = o.getComputedStyle(r)[i],\n            d = a(l),\n            u = a(s),\n            c = Number.POSITIVE_INFINITY;\n          return d || u ? Math.min(d ? e(l, t, n) : c, u ? e(s, r, n) : c) : \"none\";\n        }\n        var o = t.helpers = {};\n        o.each = function (t, e, a, i) {\n          var n, r;\n          if (o.isArray(t)) {\n            if (r = t.length, i) for (n = r - 1; n >= 0; n--) e.call(a, t[n], n);else for (n = 0; r > n; n++) e.call(a, t[n], n);\n          } else if (\"object\" == typeof t) {\n            var l = Object.keys(t);\n            for (r = l.length, n = 0; r > n; n++) e.call(a, t[l[n]], l[n]);\n          }\n        }, o.clone = function (t) {\n          var e = {};\n          return o.each(t, function (t, a) {\n            o.isArray(t) ? e[a] = t.slice(0) : \"object\" == typeof t && null !== t ? e[a] = o.clone(t) : e[a] = t;\n          }), e;\n        }, o.extend = function (t) {\n          for (var e = function (e, a) {\n              t[a] = e;\n            }, a = 1, i = arguments.length; i > a; a++) o.each(arguments[a], e);\n          return t;\n        }, o.configMerge = function (e) {\n          var a = o.clone(e);\n          return o.each(Array.prototype.slice.call(arguments, 1), function (e) {\n            o.each(e, function (e, i) {\n              if (\"scales\" === i) a[i] = o.scaleMerge(a.hasOwnProperty(i) ? a[i] : {}, e);else if (\"scale\" === i) a[i] = o.configMerge(a.hasOwnProperty(i) ? a[i] : {}, t.scaleService.getScaleDefaults(e.type), e);else if (a.hasOwnProperty(i) && o.isArray(a[i]) && o.isArray(e)) {\n                var n = a[i];\n                o.each(e, function (t, e) {\n                  e < n.length ? \"object\" == typeof n[e] && null !== n[e] && \"object\" == typeof t && null !== t ? n[e] = o.configMerge(n[e], t) : n[e] = t : n.push(t);\n                });\n              } else a.hasOwnProperty(i) && \"object\" == typeof a[i] && null !== a[i] && \"object\" == typeof e ? a[i] = o.configMerge(a[i], e) : a[i] = e;\n            });\n          }), a;\n        }, o.scaleMerge = function (e, a) {\n          var i = o.clone(e);\n          return o.each(a, function (e, a) {\n            \"xAxes\" === a || \"yAxes\" === a ? i.hasOwnProperty(a) ? o.each(e, function (e, n) {\n              var r = o.getValueOrDefault(e.type, \"xAxes\" === a ? \"category\" : \"linear\"),\n                l = t.scaleService.getScaleDefaults(r);\n              n >= i[a].length || !i[a][n].type ? i[a].push(o.configMerge(l, e)) : e.type && e.type !== i[a][n].type ? i[a][n] = o.configMerge(i[a][n], l, e) : i[a][n] = o.configMerge(i[a][n], e);\n            }) : (i[a] = [], o.each(e, function (e) {\n              var n = o.getValueOrDefault(e.type, \"xAxes\" === a ? \"category\" : \"linear\");\n              i[a].push(o.configMerge(t.scaleService.getScaleDefaults(n), e));\n            })) : i.hasOwnProperty(a) && \"object\" == typeof i[a] && null !== i[a] && \"object\" == typeof e ? i[a] = o.configMerge(i[a], e) : i[a] = e;\n          }), i;\n        }, o.getValueAtIndexOrDefault = function (t, e, a) {\n          return void 0 === t || null === t ? a : o.isArray(t) ? e < t.length ? t[e] : a : t;\n        }, o.getValueOrDefault = function (t, e) {\n          return void 0 === t ? e : t;\n        }, o.indexOf = Array.prototype.indexOf ? function (t, e) {\n          return t.indexOf(e);\n        } : function (t, e) {\n          for (var a = 0, i = t.length; i > a; ++a) if (t[a] === e) return a;\n          return -1;\n        }, o.where = function (t, e) {\n          if (o.isArray(t) && Array.prototype.filter) return t.filter(e);\n          var a = [];\n          return o.each(t, function (t) {\n            e(t) && a.push(t);\n          }), a;\n        }, o.findIndex = Array.prototype.findIndex ? function (t, e, a) {\n          return t.findIndex(e, a);\n        } : function (t, e, a) {\n          a = void 0 === a ? t : a;\n          for (var i = 0, n = t.length; n > i; ++i) if (e.call(a, t[i], i, t)) return i;\n          return -1;\n        }, o.findNextWhere = function (t, e, a) {\n          (void 0 === a || null === a) && (a = -1);\n          for (var i = a + 1; i < t.length; i++) {\n            var n = t[i];\n            if (e(n)) return n;\n          }\n        }, o.findPreviousWhere = function (t, e, a) {\n          (void 0 === a || null === a) && (a = t.length);\n          for (var i = a - 1; i >= 0; i--) {\n            var n = t[i];\n            if (e(n)) return n;\n          }\n        }, o.inherits = function (t) {\n          var e = this,\n            a = t && t.hasOwnProperty(\"constructor\") ? t.constructor : function () {\n              return e.apply(this, arguments);\n            },\n            i = function () {\n              this.constructor = a;\n            };\n          return i.prototype = e.prototype, a.prototype = new i(), a.extend = o.inherits, t && o.extend(a.prototype, t), a.__super__ = e.prototype, a;\n        }, o.noop = function () {}, o.uid = function () {\n          var t = 0;\n          return function () {\n            return t++;\n          };\n        }(), o.isNumber = function (t) {\n          return !isNaN(parseFloat(t)) && isFinite(t);\n        }, o.almostEquals = function (t, e, a) {\n          return Math.abs(t - e) < a;\n        }, o.max = function (t) {\n          return t.reduce(function (t, e) {\n            return isNaN(e) ? t : Math.max(t, e);\n          }, Number.NEGATIVE_INFINITY);\n        }, o.min = function (t) {\n          return t.reduce(function (t, e) {\n            return isNaN(e) ? t : Math.min(t, e);\n          }, Number.POSITIVE_INFINITY);\n        }, o.sign = Math.sign ? function (t) {\n          return Math.sign(t);\n        } : function (t) {\n          return t = +t, 0 === t || isNaN(t) ? t : t > 0 ? 1 : -1;\n        }, o.log10 = Math.log10 ? function (t) {\n          return Math.log10(t);\n        } : function (t) {\n          return Math.log(t) / Math.LN10;\n        }, o.toRadians = function (t) {\n          return t * (Math.PI / 180);\n        }, o.toDegrees = function (t) {\n          return t * (180 / Math.PI);\n        }, o.getAngleFromPoint = function (t, e) {\n          var a = e.x - t.x,\n            i = e.y - t.y,\n            n = Math.sqrt(a * a + i * i),\n            o = Math.atan2(i, a);\n          return o < -.5 * Math.PI && (o += 2 * Math.PI), {\n            angle: o,\n            distance: n\n          };\n        }, o.aliasPixel = function (t) {\n          return t % 2 === 0 ? 0 : .5;\n        }, o.splineCurve = function (t, e, a, i) {\n          var n = t.skip ? e : t,\n            o = e,\n            r = a.skip ? e : a,\n            l = Math.sqrt(Math.pow(o.x - n.x, 2) + Math.pow(o.y - n.y, 2)),\n            s = Math.sqrt(Math.pow(r.x - o.x, 2) + Math.pow(r.y - o.y, 2)),\n            d = l / (l + s),\n            u = s / (l + s);\n          d = isNaN(d) ? 0 : d, u = isNaN(u) ? 0 : u;\n          var c = i * d,\n            h = i * u;\n          return {\n            previous: {\n              x: o.x - c * (r.x - n.x),\n              y: o.y - c * (r.y - n.y)\n            },\n            next: {\n              x: o.x + h * (r.x - n.x),\n              y: o.y + h * (r.y - n.y)\n            }\n          };\n        }, o.nextItem = function (t, e, a) {\n          return a ? e >= t.length - 1 ? t[0] : t[e + 1] : e >= t.length - 1 ? t[t.length - 1] : t[e + 1];\n        }, o.previousItem = function (t, e, a) {\n          return a ? 0 >= e ? t[t.length - 1] : t[e - 1] : 0 >= e ? t[0] : t[e - 1];\n        }, o.niceNum = function (t, e) {\n          var a,\n            i = Math.floor(o.log10(t)),\n            n = t / Math.pow(10, i);\n          return a = e ? 1.5 > n ? 1 : 3 > n ? 2 : 7 > n ? 5 : 10 : 1 >= n ? 1 : 2 >= n ? 2 : 5 >= n ? 5 : 10, a * Math.pow(10, i);\n        };\n        var r = o.easingEffects = {\n          linear: function (t) {\n            return t;\n          },\n          easeInQuad: function (t) {\n            return t * t;\n          },\n          easeOutQuad: function (t) {\n            return -1 * t * (t - 2);\n          },\n          easeInOutQuad: function (t) {\n            return (t /= .5) < 1 ? .5 * t * t : -0.5 * (--t * (t - 2) - 1);\n          },\n          easeInCubic: function (t) {\n            return t * t * t;\n          },\n          easeOutCubic: function (t) {\n            return 1 * ((t = t / 1 - 1) * t * t + 1);\n          },\n          easeInOutCubic: function (t) {\n            return (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2);\n          },\n          easeInQuart: function (t) {\n            return t * t * t * t;\n          },\n          easeOutQuart: function (t) {\n            return -1 * ((t = t / 1 - 1) * t * t * t - 1);\n          },\n          easeInOutQuart: function (t) {\n            return (t /= .5) < 1 ? .5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2);\n          },\n          easeInQuint: function (t) {\n            return 1 * (t /= 1) * t * t * t * t;\n          },\n          easeOutQuint: function (t) {\n            return 1 * ((t = t / 1 - 1) * t * t * t * t + 1);\n          },\n          easeInOutQuint: function (t) {\n            return (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2);\n          },\n          easeInSine: function (t) {\n            return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;\n          },\n          easeOutSine: function (t) {\n            return 1 * Math.sin(t / 1 * (Math.PI / 2));\n          },\n          easeInOutSine: function (t) {\n            return -0.5 * (Math.cos(Math.PI * t / 1) - 1);\n          },\n          easeInExpo: function (t) {\n            return 0 === t ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));\n          },\n          easeOutExpo: function (t) {\n            return 1 === t ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);\n          },\n          easeInOutExpo: function (t) {\n            return 0 === t ? 0 : 1 === t ? 1 : (t /= .5) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (-Math.pow(2, -10 * --t) + 2);\n          },\n          easeInCirc: function (t) {\n            return t >= 1 ? t : -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);\n          },\n          easeOutCirc: function (t) {\n            return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);\n          },\n          easeInOutCirc: function (t) {\n            return (t /= .5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n          },\n          easeInElastic: function (t) {\n            var e = 1.70158,\n              a = 0,\n              i = 1;\n            return 0 === t ? 0 : 1 === (t /= 1) ? 1 : (a || (a = .3), i < Math.abs(1) ? (i = 1, e = a / 4) : e = a / (2 * Math.PI) * Math.asin(1 / i), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / a)));\n          },\n          easeOutElastic: function (t) {\n            var e = 1.70158,\n              a = 0,\n              i = 1;\n            return 0 === t ? 0 : 1 === (t /= 1) ? 1 : (a || (a = .3), i < Math.abs(1) ? (i = 1, e = a / 4) : e = a / (2 * Math.PI) * Math.asin(1 / i), i * Math.pow(2, -10 * t) * Math.sin((1 * t - e) * (2 * Math.PI) / a) + 1);\n          },\n          easeInOutElastic: function (t) {\n            var e = 1.70158,\n              a = 0,\n              i = 1;\n            return 0 === t ? 0 : 2 === (t /= .5) ? 1 : (a || (a = 1 * (.3 * 1.5)), i < Math.abs(1) ? (i = 1, e = a / 4) : e = a / (2 * Math.PI) * Math.asin(1 / i), 1 > t ? -.5 * (i * Math.pow(2, 10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / a)) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / a) * .5 + 1);\n          },\n          easeInBack: function (t) {\n            var e = 1.70158;\n            return 1 * (t /= 1) * t * ((e + 1) * t - e);\n          },\n          easeOutBack: function (t) {\n            var e = 1.70158;\n            return 1 * ((t = t / 1 - 1) * t * ((e + 1) * t + e) + 1);\n          },\n          easeInOutBack: function (t) {\n            var e = 1.70158;\n            return (t /= .5) < 1 ? .5 * (t * t * (((e *= 1.525) + 1) * t - e)) : .5 * ((t -= 2) * t * (((e *= 1.525) + 1) * t + e) + 2);\n          },\n          easeInBounce: function (t) {\n            return 1 - r.easeOutBounce(1 - t);\n          },\n          easeOutBounce: function (t) {\n            return (t /= 1) < 1 / 2.75 ? 1 * (7.5625 * t * t) : 2 / 2.75 > t ? 1 * (7.5625 * (t -= 1.5 / 2.75) * t + .75) : 2.5 / 2.75 > t ? 1 * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 * (7.5625 * (t -= 2.625 / 2.75) * t + .984375);\n          },\n          easeInOutBounce: function (t) {\n            return .5 > t ? .5 * r.easeInBounce(2 * t) : .5 * r.easeOutBounce(2 * t - 1) + .5;\n          }\n        };\n        o.requestAnimFrame = function () {\n          return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) {\n            return window.setTimeout(t, 1e3 / 60);\n          };\n        }(), o.cancelAnimFrame = function () {\n          return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (t) {\n            return window.clearTimeout(t, 1e3 / 60);\n          };\n        }(), o.getRelativePosition = function (t, e) {\n          var a,\n            i,\n            n = t.originalEvent || t,\n            r = t.currentTarget || t.srcElement,\n            l = r.getBoundingClientRect(),\n            s = n.touches;\n          s && s.length > 0 ? (a = s[0].clientX, i = s[0].clientY) : (a = n.clientX, i = n.clientY);\n          var d = parseFloat(o.getStyle(r, \"padding-left\")),\n            u = parseFloat(o.getStyle(r, \"padding-top\")),\n            c = parseFloat(o.getStyle(r, \"padding-right\")),\n            h = parseFloat(o.getStyle(r, \"padding-bottom\")),\n            f = l.right - l.left - d - c,\n            g = l.bottom - l.top - u - h;\n          return a = Math.round((a - l.left - d) / f * r.width / e.currentDevicePixelRatio), i = Math.round((i - l.top - u) / g * r.height / e.currentDevicePixelRatio), {\n            x: a,\n            y: i\n          };\n        }, o.addEvent = function (t, e, a) {\n          t.addEventListener ? t.addEventListener(e, a) : t.attachEvent ? t.attachEvent(\"on\" + e, a) : t[\"on\" + e] = a;\n        }, o.removeEvent = function (t, e, a) {\n          t.removeEventListener ? t.removeEventListener(e, a, !1) : t.detachEvent ? t.detachEvent(\"on\" + e, a) : t[\"on\" + e] = o.noop;\n        }, o.bindEvents = function (t, e, a) {\n          var i = t.events = t.events || {};\n          o.each(e, function (e) {\n            i[e] = function () {\n              a.apply(t, arguments);\n            }, o.addEvent(t.chart.canvas, e, i[e]);\n          });\n        }, o.unbindEvents = function (t, e) {\n          var a = t.chart.canvas;\n          o.each(e, function (t, e) {\n            o.removeEvent(a, e, t);\n          });\n        }, o.getConstraintWidth = function (t) {\n          return n(t, \"max-width\", \"clientWidth\");\n        }, o.getConstraintHeight = function (t) {\n          return n(t, \"max-height\", \"clientHeight\");\n        }, o.getMaximumWidth = function (t) {\n          var e = t.parentNode,\n            a = parseInt(o.getStyle(e, \"padding-left\")) + parseInt(o.getStyle(e, \"padding-right\")),\n            i = e.clientWidth - a,\n            n = o.getConstraintWidth(t);\n          return isNaN(n) ? i : Math.min(i, n);\n        }, o.getMaximumHeight = function (t) {\n          var e = t.parentNode,\n            a = parseInt(o.getStyle(e, \"padding-top\")) + parseInt(o.getStyle(e, \"padding-bottom\")),\n            i = e.clientHeight - a,\n            n = o.getConstraintHeight(t);\n          return isNaN(n) ? i : Math.min(i, n);\n        }, o.getStyle = function (t, e) {\n          return t.currentStyle ? t.currentStyle[e] : document.defaultView.getComputedStyle(t, null).getPropertyValue(e);\n        }, o.retinaScale = function (t) {\n          var e = t.ctx,\n            a = t.canvas,\n            i = a.width,\n            n = a.height,\n            o = t.currentDevicePixelRatio = window.devicePixelRatio || 1;\n          1 !== o && (a.height = n * o, a.width = i * o, e.scale(o, o), t.originalDevicePixelRatio = t.originalDevicePixelRatio || o), a.style.width = i + \"px\", a.style.height = n + \"px\";\n        }, o.clear = function (t) {\n          t.ctx.clearRect(0, 0, t.width, t.height);\n        }, o.fontString = function (t, e, a) {\n          return e + \" \" + t + \"px \" + a;\n        }, o.longestText = function (t, e, a, i) {\n          i = i || {};\n          var n = i.data = i.data || {},\n            r = i.garbageCollect = i.garbageCollect || [];\n          i.font !== e && (n = i.data = {}, r = i.garbageCollect = [], i.font = e), t.font = e;\n          var l = 0;\n          o.each(a, function (e) {\n            void 0 !== e && null !== e && o.isArray(e) !== !0 ? l = o.measureText(t, n, r, l, e) : o.isArray(e) && o.each(e, function (e) {\n              void 0 === e || null === e || o.isArray(e) || (l = o.measureText(t, n, r, l, e));\n            });\n          });\n          var s = r.length / 2;\n          if (s > a.length) {\n            for (var d = 0; s > d; d++) delete n[r[d]];\n            r.splice(0, s);\n          }\n          return l;\n        }, o.measureText = function (t, e, a, i, n) {\n          var o = e[n];\n          return o || (o = e[n] = t.measureText(n).width, a.push(n)), o > i && (i = o), i;\n        }, o.numberOfLabelLines = function (t) {\n          var e = 1;\n          return o.each(t, function (t) {\n            o.isArray(t) && t.length > e && (e = t.length);\n          }), e;\n        }, o.drawRoundedRectangle = function (t, e, a, i, n, o) {\n          t.beginPath(), t.moveTo(e + o, a), t.lineTo(e + i - o, a), t.quadraticCurveTo(e + i, a, e + i, a + o), t.lineTo(e + i, a + n - o), t.quadraticCurveTo(e + i, a + n, e + i - o, a + n), t.lineTo(e + o, a + n), t.quadraticCurveTo(e, a + n, e, a + n - o), t.lineTo(e, a + o), t.quadraticCurveTo(e, a, e + o, a), t.closePath();\n        }, o.color = function (e) {\n          return i ? i(e instanceof CanvasGradient ? t.defaults.global.defaultColor : e) : (console.log(\"Color.js not found!\"), e);\n        }, o.addResizeListener = function (t, e) {\n          var a = document.createElement(\"iframe\"),\n            i = \"chartjs-hidden-iframe\";\n          a.classlist ? a.classlist.add(i) : a.setAttribute(\"class\", i);\n          var n = a.style;\n          n.width = \"100%\", n.display = \"block\", n.border = 0, n.height = 0, n.margin = 0, n.position = \"absolute\", n.left = 0, n.right = 0, n.top = 0, n.bottom = 0, t.insertBefore(a, t.firstChild), (a.contentWindow || a).onresize = function () {\n            e && e();\n          };\n        }, o.removeResizeListener = function (t) {\n          var e = t.querySelector(\".chartjs-hidden-iframe\");\n          e && e.parentNode.removeChild(e);\n        }, o.isArray = Array.isArray ? function (t) {\n          return Array.isArray(t);\n        } : function (t) {\n          return \"[object Array]\" === Object.prototype.toString.call(t);\n        }, o.arrayEquals = function (t, e) {\n          var a, i, n, r;\n          if (!t || !e || t.length != e.length) return !1;\n          for (a = 0, i = t.length; i > a; ++a) if (n = t[a], r = e[a], n instanceof Array && r instanceof Array) {\n            if (!o.arrayEquals(n, r)) return !1;\n          } else if (n != r) return !1;\n          return !0;\n        }, o.callCallback = function (t, e, a) {\n          t && \"function\" == typeof t.call && t.apply(a, e);\n        }, o.getHoverColor = function (t) {\n          return t instanceof CanvasPattern ? t : o.color(t).saturate(.5).darken(.1).rgbString();\n        };\n      };\n    }, {\n      3: 3\n    }],\n    26: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function () {\n        var t = function (e, a) {\n          var i = this,\n            n = t.helpers;\n          return i.config = a, e.length && e[0].getContext && (e = e[0]), e.getContext && (e = e.getContext(\"2d\")), i.ctx = e, i.canvas = e.canvas, e.canvas.style.display = e.canvas.style.display || \"block\", i.width = e.canvas.width || parseInt(n.getStyle(e.canvas, \"width\"), 10) || n.getMaximumWidth(e.canvas), i.height = e.canvas.height || parseInt(n.getStyle(e.canvas, \"height\"), 10) || n.getMaximumHeight(e.canvas), i.aspectRatio = i.width / i.height, (isNaN(i.aspectRatio) || isFinite(i.aspectRatio) === !1) && (i.aspectRatio = void 0 !== a.aspectRatio ? a.aspectRatio : 2), i.originalCanvasStyleWidth = e.canvas.style.width, i.originalCanvasStyleHeight = e.canvas.style.height, n.retinaScale(i), a && (i.controller = new t.Controller(i)), n.addResizeListener(e.canvas.parentNode, function () {\n            i.controller && i.controller.config.options.responsive && i.controller.resize();\n          }), i.controller ? i.controller : i;\n        };\n        return t.defaults = {\n          global: {\n            responsive: !0,\n            responsiveAnimationDuration: 0,\n            maintainAspectRatio: !0,\n            events: [\"mousemove\", \"mouseout\", \"click\", \"touchstart\", \"touchmove\"],\n            hover: {\n              onHover: null,\n              mode: \"single\",\n              animationDuration: 400\n            },\n            onClick: null,\n            defaultColor: \"rgba(0,0,0,0.1)\",\n            defaultFontColor: \"#666\",\n            defaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n            defaultFontSize: 12,\n            defaultFontStyle: \"normal\",\n            showLines: !0,\n            elements: {},\n            legendCallback: function (t) {\n              var e = [];\n              e.push('<ul class=\"' + t.id + '-legend\">');\n              for (var a = 0; a < t.data.datasets.length; a++) e.push('<li><span style=\"background-color:' + t.data.datasets[a].backgroundColor + '\"></span>'), t.data.datasets[a].label && e.push(t.data.datasets[a].label), e.push(\"</li>\");\n              return e.push(\"</ul>\"), e.join(\"\");\n            }\n          }\n        }, t.Chart = t, t;\n      };\n    }, {}],\n    27: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers;\n        t.layoutService = {\n          defaults: {},\n          addBox: function (t, e) {\n            t.boxes || (t.boxes = []), t.boxes.push(e);\n          },\n          removeBox: function (t, e) {\n            t.boxes && t.boxes.splice(t.boxes.indexOf(e), 1);\n          },\n          update: function (t, a, i) {\n            function n(t) {\n              var e,\n                a = t.isHorizontal();\n              a ? (e = t.update(t.options.fullWidth ? p : k, y), S -= e.height) : (e = t.update(x, v), k -= e.width), w.push({\n                horizontal: a,\n                minSize: e,\n                box: t\n              });\n            }\n            function o(t) {\n              var a = e.findNextWhere(w, function (e) {\n                return e.box === t;\n              });\n              if (a) if (t.isHorizontal()) {\n                var i = {\n                  left: C,\n                  right: M,\n                  top: 0,\n                  bottom: 0\n                };\n                t.update(t.options.fullWidth ? p : k, m / 2, i);\n              } else t.update(a.minSize.width, S);\n            }\n            function r(t) {\n              var a = e.findNextWhere(w, function (e) {\n                  return e.box === t;\n                }),\n                i = {\n                  left: 0,\n                  right: 0,\n                  top: D,\n                  bottom: A\n                };\n              a && t.update(a.minSize.width, S, i);\n            }\n            function l(t) {\n              t.isHorizontal() ? (t.left = t.options.fullWidth ? s : C, t.right = t.options.fullWidth ? a - s : C + k, t.top = P, t.bottom = P + t.height, P = t.bottom) : (t.left = T, t.right = T + t.width, t.top = D, t.bottom = D + S, T = t.right);\n            }\n            if (t) {\n              var s = 0,\n                d = 0,\n                u = e.where(t.boxes, function (t) {\n                  return \"left\" === t.options.position;\n                }),\n                c = e.where(t.boxes, function (t) {\n                  return \"right\" === t.options.position;\n                }),\n                h = e.where(t.boxes, function (t) {\n                  return \"top\" === t.options.position;\n                }),\n                f = e.where(t.boxes, function (t) {\n                  return \"bottom\" === t.options.position;\n                }),\n                g = e.where(t.boxes, function (t) {\n                  return \"chartArea\" === t.options.position;\n                });\n              h.sort(function (t, e) {\n                return (e.options.fullWidth ? 1 : 0) - (t.options.fullWidth ? 1 : 0);\n              }), f.sort(function (t, e) {\n                return (t.options.fullWidth ? 1 : 0) - (e.options.fullWidth ? 1 : 0);\n              });\n              var p = a - 2 * s,\n                m = i - 2 * d,\n                b = p / 2,\n                v = m / 2,\n                x = (a - b) / (u.length + c.length),\n                y = (i - v) / (h.length + f.length),\n                k = p,\n                S = m,\n                w = [];\n              e.each(u.concat(c, h, f), n);\n              var C = s,\n                M = s,\n                D = d,\n                A = d;\n              e.each(u.concat(c), o), e.each(u, function (t) {\n                C += t.width;\n              }), e.each(c, function (t) {\n                M += t.width;\n              }), e.each(h.concat(f), o), e.each(h, function (t) {\n                D += t.height;\n              }), e.each(f, function (t) {\n                A += t.height;\n              }), e.each(u.concat(c), r), C = s, M = s, D = d, A = d, e.each(u, function (t) {\n                C += t.width;\n              }), e.each(c, function (t) {\n                M += t.width;\n              }), e.each(h, function (t) {\n                D += t.height;\n              }), e.each(f, function (t) {\n                A += t.height;\n              });\n              var I = i - D - A,\n                F = a - C - M;\n              (F !== k || I !== S) && (e.each(u, function (t) {\n                t.height = I;\n              }), e.each(c, function (t) {\n                t.height = I;\n              }), e.each(h, function (t) {\n                t.options.fullWidth || (t.width = F);\n              }), e.each(f, function (t) {\n                t.options.fullWidth || (t.width = F);\n              }), S = I, k = F);\n              var T = s,\n                P = d;\n              e.each(u.concat(h), l), T += k, P += S, e.each(c, l), e.each(f, l), t.chartArea = {\n                left: C,\n                top: D,\n                right: C + k,\n                bottom: D + S\n              }, e.each(g, function (e) {\n                e.left = t.chartArea.left, e.top = t.chartArea.top, e.right = t.chartArea.right, e.bottom = t.chartArea.bottom, e.update(k, S);\n              });\n            }\n          }\n        };\n      };\n    }, {}],\n    28: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers,\n          a = e.noop;\n        t.defaults.global.legend = {\n          display: !0,\n          position: \"top\",\n          fullWidth: !0,\n          reverse: !1,\n          onClick: function (t, e) {\n            var a = e.datasetIndex,\n              i = this.chart,\n              n = i.getDatasetMeta(a);\n            n.hidden = null === n.hidden ? !i.data.datasets[a].hidden : null, i.update();\n          },\n          labels: {\n            boxWidth: 40,\n            padding: 10,\n            generateLabels: function (t) {\n              var a = t.data;\n              return e.isArray(a.datasets) ? a.datasets.map(function (a, i) {\n                return {\n                  text: a.label,\n                  fillStyle: e.isArray(a.backgroundColor) ? a.backgroundColor[0] : a.backgroundColor,\n                  hidden: !t.isDatasetVisible(i),\n                  lineCap: a.borderCapStyle,\n                  lineDash: a.borderDash,\n                  lineDashOffset: a.borderDashOffset,\n                  lineJoin: a.borderJoinStyle,\n                  lineWidth: a.borderWidth,\n                  strokeStyle: a.borderColor,\n                  datasetIndex: i\n                };\n              }, this) : [];\n            }\n          }\n        }, t.Legend = t.Element.extend({\n          initialize: function (t) {\n            e.extend(this, t), this.legendHitBoxes = [], this.doughnutMode = !1;\n          },\n          beforeUpdate: a,\n          update: function (t, e, a) {\n            var i = this;\n            return i.beforeUpdate(), i.maxWidth = t, i.maxHeight = e, i.margins = a, i.beforeSetDimensions(), i.setDimensions(), i.afterSetDimensions(), i.beforeBuildLabels(), i.buildLabels(), i.afterBuildLabels(), i.beforeFit(), i.fit(), i.afterFit(), i.afterUpdate(), i.minSize;\n          },\n          afterUpdate: a,\n          beforeSetDimensions: a,\n          setDimensions: function () {\n            var t = this;\n            t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = {\n              width: 0,\n              height: 0\n            };\n          },\n          afterSetDimensions: a,\n          beforeBuildLabels: a,\n          buildLabels: function () {\n            var t = this;\n            t.legendItems = t.options.labels.generateLabels.call(t, t.chart), t.options.reverse && t.legendItems.reverse();\n          },\n          afterBuildLabels: a,\n          beforeFit: a,\n          fit: function () {\n            var a = this,\n              i = a.options,\n              n = i.labels,\n              o = i.display,\n              r = a.ctx,\n              l = t.defaults.global,\n              s = e.getValueOrDefault,\n              d = s(n.fontSize, l.defaultFontSize),\n              u = s(n.fontStyle, l.defaultFontStyle),\n              c = s(n.fontFamily, l.defaultFontFamily),\n              h = e.fontString(d, u, c),\n              f = a.legendHitBoxes = [],\n              g = a.minSize,\n              p = a.isHorizontal();\n            if (p ? (g.width = a.maxWidth, g.height = o ? 10 : 0) : (g.width = o ? 10 : 0, g.height = a.maxHeight), o) if (r.font = h, p) {\n              var m = a.lineWidths = [0],\n                b = a.legendItems.length ? d + n.padding : 0;\n              r.textAlign = \"left\", r.textBaseline = \"top\", e.each(a.legendItems, function (t, e) {\n                var i = n.boxWidth + d / 2 + r.measureText(t.text).width;\n                m[m.length - 1] + i + n.padding >= a.width && (b += d + n.padding, m[m.length] = a.left), f[e] = {\n                  left: 0,\n                  top: 0,\n                  width: i,\n                  height: d\n                }, m[m.length - 1] += i + n.padding;\n              }), g.height += b;\n            } else {\n              var v = n.padding,\n                x = a.columnWidths = [],\n                y = n.padding,\n                k = 0,\n                S = 0,\n                w = d + v;\n              e.each(a.legendItems, function (t, e) {\n                var a = n.boxWidth + d / 2 + r.measureText(t.text).width;\n                S + w > g.height && (y += k + n.padding, x.push(k), k = 0, S = 0), k = Math.max(k, a), S += w, f[e] = {\n                  left: 0,\n                  top: 0,\n                  width: a,\n                  height: d\n                };\n              }), y += k, x.push(k), g.width += y;\n            }\n            a.width = g.width, a.height = g.height;\n          },\n          afterFit: a,\n          isHorizontal: function () {\n            return \"top\" === this.options.position || \"bottom\" === this.options.position;\n          },\n          draw: function () {\n            var a = this,\n              i = a.options,\n              n = i.labels,\n              o = t.defaults.global,\n              r = o.elements.line,\n              l = a.width,\n              s = (a.height, a.lineWidths);\n            if (i.display) {\n              var d,\n                u = a.ctx,\n                c = e.getValueOrDefault,\n                h = c(n.fontColor, o.defaultFontColor),\n                f = c(n.fontSize, o.defaultFontSize),\n                g = c(n.fontStyle, o.defaultFontStyle),\n                p = c(n.fontFamily, o.defaultFontFamily),\n                m = e.fontString(f, g, p);\n              u.textAlign = \"left\", u.textBaseline = \"top\", u.lineWidth = .5, u.strokeStyle = h, u.fillStyle = h, u.font = m;\n              var b = n.boxWidth,\n                v = a.legendHitBoxes,\n                x = function (t, e, a) {\n                  u.save(), u.fillStyle = c(a.fillStyle, o.defaultColor), u.lineCap = c(a.lineCap, r.borderCapStyle), u.lineDashOffset = c(a.lineDashOffset, r.borderDashOffset), u.lineJoin = c(a.lineJoin, r.borderJoinStyle), u.lineWidth = c(a.lineWidth, r.borderWidth), u.strokeStyle = c(a.strokeStyle, o.defaultColor), u.setLineDash && u.setLineDash(c(a.lineDash, r.borderDash)), u.strokeRect(t, e, b, f), u.fillRect(t, e, b, f), u.restore();\n                },\n                y = function (t, e, a, i) {\n                  u.fillText(a.text, b + f / 2 + t, e), a.hidden && (u.beginPath(), u.lineWidth = 2, u.moveTo(b + f / 2 + t, e + f / 2), u.lineTo(b + f / 2 + t + i, e + f / 2), u.stroke());\n                },\n                k = a.isHorizontal();\n              d = k ? {\n                x: a.left + (l - s[0]) / 2,\n                y: a.top + n.padding,\n                line: 0\n              } : {\n                x: a.left + n.padding,\n                y: a.top,\n                line: 0\n              };\n              var S = f + n.padding;\n              e.each(a.legendItems, function (t, e) {\n                var i = u.measureText(t.text).width,\n                  o = b + f / 2 + i,\n                  r = d.x,\n                  c = d.y;\n                k ? r + o >= l && (c = d.y += f + n.padding, d.line++, r = d.x = a.left + (l - s[d.line]) / 2) : c + S > a.bottom && (r = d.x = r + a.columnWidths[d.line] + n.padding, c = d.y = a.top, d.line++), x(r, c, t), v[e].left = r, v[e].top = c, y(r, c, t, i), k ? d.x += o + n.padding : d.y += S;\n              });\n            }\n          },\n          handleEvent: function (t) {\n            var a = this,\n              i = e.getRelativePosition(t, a.chart.chart),\n              n = i.x,\n              o = i.y,\n              r = a.options;\n            if (n >= a.left && n <= a.right && o >= a.top && o <= a.bottom) for (var l = a.legendHitBoxes, s = 0; s < l.length; ++s) {\n              var d = l[s];\n              if (n >= d.left && n <= d.left + d.width && o >= d.top && o <= d.top + d.height) {\n                r.onClick && r.onClick.call(a, t, a.legendItems[s]);\n                break;\n              }\n            }\n          }\n        }), t.plugins.register({\n          beforeInit: function (e) {\n            var a = e.options,\n              i = a.legend;\n            i && (e.legend = new t.Legend({\n              ctx: e.chart.ctx,\n              options: i,\n              chart: e\n            }), t.layoutService.addBox(e, e.legend));\n          }\n        });\n      };\n    }, {}],\n    29: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers.noop;\n        t.plugins = {\n          _plugins: [],\n          register: function (t) {\n            var e = this._plugins;\n            [].concat(t).forEach(function (t) {\n              -1 === e.indexOf(t) && e.push(t);\n            });\n          },\n          unregister: function (t) {\n            var e = this._plugins;\n            [].concat(t).forEach(function (t) {\n              var a = e.indexOf(t);\n              -1 !== a && e.splice(a, 1);\n            });\n          },\n          clear: function () {\n            this._plugins = [];\n          },\n          count: function () {\n            return this._plugins.length;\n          },\n          getAll: function () {\n            return this._plugins;\n          },\n          notify: function (t, e) {\n            var a,\n              i,\n              n = this._plugins,\n              o = n.length;\n            for (a = 0; o > a; ++a) if (i = n[a], \"function\" == typeof i[t] && i[t].apply(i, e || []) === !1) return !1;\n            return !0;\n          }\n        }, t.PluginBase = t.Element.extend({\n          beforeInit: e,\n          afterInit: e,\n          beforeUpdate: e,\n          afterUpdate: e,\n          beforeDraw: e,\n          afterDraw: e,\n          destroy: e\n        }), t.pluginService = t.plugins;\n      };\n    }, {}],\n    30: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers;\n        t.defaults.scale = {\n          display: !0,\n          position: \"left\",\n          gridLines: {\n            display: !0,\n            color: \"rgba(0, 0, 0, 0.1)\",\n            lineWidth: 1,\n            drawBorder: !0,\n            drawOnChartArea: !0,\n            drawTicks: !0,\n            tickMarkLength: 10,\n            zeroLineWidth: 1,\n            zeroLineColor: \"rgba(0,0,0,0.25)\",\n            offsetGridLines: !1\n          },\n          scaleLabel: {\n            labelString: \"\",\n            display: !1\n          },\n          ticks: {\n            beginAtZero: !1,\n            minRotation: 0,\n            maxRotation: 50,\n            mirror: !1,\n            padding: 10,\n            reverse: !1,\n            display: !0,\n            autoSkip: !0,\n            autoSkipPadding: 0,\n            labelOffset: 0,\n            callback: function (t) {\n              return e.isArray(t) ? t : \"\" + t;\n            }\n          }\n        }, t.Scale = t.Element.extend({\n          beforeUpdate: function () {\n            e.callCallback(this.options.beforeUpdate, [this]);\n          },\n          update: function (t, a, i) {\n            var n = this;\n            return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = a, n.margins = e.extend({\n              left: 0,\n              right: 0,\n              top: 0,\n              bottom: 0\n            }, i), n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeDataLimits(), n.determineDataLimits(), n.afterDataLimits(), n.beforeBuildTicks(), n.buildTicks(), n.afterBuildTicks(), n.beforeTickToLabelConversion(), n.convertTicksToLabels(), n.afterTickToLabelConversion(), n.beforeCalculateTickRotation(), n.calculateTickRotation(), n.afterCalculateTickRotation(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize;\n          },\n          afterUpdate: function () {\n            e.callCallback(this.options.afterUpdate, [this]);\n          },\n          beforeSetDimensions: function () {\n            e.callCallback(this.options.beforeSetDimensions, [this]);\n          },\n          setDimensions: function () {\n            var t = this;\n            t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0;\n          },\n          afterSetDimensions: function () {\n            e.callCallback(this.options.afterSetDimensions, [this]);\n          },\n          beforeDataLimits: function () {\n            e.callCallback(this.options.beforeDataLimits, [this]);\n          },\n          determineDataLimits: e.noop,\n          afterDataLimits: function () {\n            e.callCallback(this.options.afterDataLimits, [this]);\n          },\n          beforeBuildTicks: function () {\n            e.callCallback(this.options.beforeBuildTicks, [this]);\n          },\n          buildTicks: e.noop,\n          afterBuildTicks: function () {\n            e.callCallback(this.options.afterBuildTicks, [this]);\n          },\n          beforeTickToLabelConversion: function () {\n            e.callCallback(this.options.beforeTickToLabelConversion, [this]);\n          },\n          convertTicksToLabels: function () {\n            var t = this;\n            t.ticks = t.ticks.map(function (e, a, i) {\n              return t.options.ticks.userCallback ? t.options.ticks.userCallback(e, a, i) : t.options.ticks.callback(e, a, i);\n            }, t);\n          },\n          afterTickToLabelConversion: function () {\n            e.callCallback(this.options.afterTickToLabelConversion, [this]);\n          },\n          beforeCalculateTickRotation: function () {\n            e.callCallback(this.options.beforeCalculateTickRotation, [this]);\n          },\n          calculateTickRotation: function () {\n            var a = this,\n              i = a.ctx,\n              n = t.defaults.global,\n              o = a.options.ticks,\n              r = e.getValueOrDefault(o.fontSize, n.defaultFontSize),\n              l = e.getValueOrDefault(o.fontStyle, n.defaultFontStyle),\n              s = e.getValueOrDefault(o.fontFamily, n.defaultFontFamily),\n              d = e.fontString(r, l, s);\n            i.font = d;\n            var u,\n              c = i.measureText(a.ticks[0]).width,\n              h = i.measureText(a.ticks[a.ticks.length - 1]).width;\n            if (a.labelRotation = o.minRotation || 0, a.paddingRight = 0, a.paddingLeft = 0, a.options.display && a.isHorizontal()) {\n              a.paddingRight = h / 2 + 3, a.paddingLeft = c / 2 + 3, a.longestTextCache || (a.longestTextCache = {});\n              for (var f, g, p = e.longestText(i, d, a.ticks, a.longestTextCache), m = p, b = a.getPixelForTick(1) - a.getPixelForTick(0) - 6; m > b && a.labelRotation < o.maxRotation;) {\n                if (f = Math.cos(e.toRadians(a.labelRotation)), g = Math.sin(e.toRadians(a.labelRotation)), u = f * c, u + r / 2 > a.yLabelWidth && (a.paddingLeft = u + r / 2), a.paddingRight = r / 2, g * p > a.maxHeight) {\n                  a.labelRotation--;\n                  break;\n                }\n                a.labelRotation++, m = f * p;\n              }\n            }\n            a.margins && (a.paddingLeft = Math.max(a.paddingLeft - a.margins.left, 0), a.paddingRight = Math.max(a.paddingRight - a.margins.right, 0));\n          },\n          afterCalculateTickRotation: function () {\n            e.callCallback(this.options.afterCalculateTickRotation, [this]);\n          },\n          beforeFit: function () {\n            e.callCallback(this.options.beforeFit, [this]);\n          },\n          fit: function () {\n            var a = this,\n              i = a.minSize = {\n                width: 0,\n                height: 0\n              },\n              n = a.options,\n              o = t.defaults.global,\n              r = n.ticks,\n              l = n.scaleLabel,\n              s = n.display,\n              d = a.isHorizontal(),\n              u = e.getValueOrDefault(r.fontSize, o.defaultFontSize),\n              c = e.getValueOrDefault(r.fontStyle, o.defaultFontStyle),\n              h = e.getValueOrDefault(r.fontFamily, o.defaultFontFamily),\n              f = e.fontString(u, c, h),\n              g = e.getValueOrDefault(l.fontSize, o.defaultFontSize),\n              p = e.getValueOrDefault(l.fontStyle, o.defaultFontStyle),\n              m = e.getValueOrDefault(l.fontFamily, o.defaultFontFamily),\n              b = (e.fontString(g, p, m), n.gridLines.tickMarkLength);\n            if (d ? i.width = a.isFullWidth() ? a.maxWidth - a.margins.left - a.margins.right : a.maxWidth : i.width = s ? b : 0, d ? i.height = s ? b : 0 : i.height = a.maxHeight, l.display && s && (d ? i.height += 1.5 * g : i.width += 1.5 * g), r.display && s) {\n              a.longestTextCache || (a.longestTextCache = {});\n              var v = e.longestText(a.ctx, f, a.ticks, a.longestTextCache),\n                x = e.numberOfLabelLines(a.ticks),\n                y = .5 * u;\n              if (d) {\n                a.longestLabelWidth = v;\n                var k = Math.sin(e.toRadians(a.labelRotation)) * a.longestLabelWidth + u * x + y * x;\n                i.height = Math.min(a.maxHeight, i.height + k), a.ctx.font = f;\n                var S = a.ctx.measureText(a.ticks[0]).width,\n                  w = a.ctx.measureText(a.ticks[a.ticks.length - 1]).width,\n                  C = Math.cos(e.toRadians(a.labelRotation)),\n                  M = Math.sin(e.toRadians(a.labelRotation));\n                a.paddingLeft = 0 !== a.labelRotation ? C * S + 3 : S / 2 + 3, a.paddingRight = 0 !== a.labelRotation ? M * (u / 2) + 3 : w / 2 + 3;\n              } else {\n                var D = a.maxWidth - i.width,\n                  A = r.mirror;\n                A ? v = 0 : v += a.options.ticks.padding, D > v ? i.width += v : i.width = a.maxWidth, a.paddingTop = u / 2, a.paddingBottom = u / 2;\n              }\n            }\n            a.margins && (a.paddingLeft = Math.max(a.paddingLeft - a.margins.left, 0), a.paddingTop = Math.max(a.paddingTop - a.margins.top, 0), a.paddingRight = Math.max(a.paddingRight - a.margins.right, 0), a.paddingBottom = Math.max(a.paddingBottom - a.margins.bottom, 0)), a.width = i.width, a.height = i.height;\n          },\n          afterFit: function () {\n            e.callCallback(this.options.afterFit, [this]);\n          },\n          isHorizontal: function () {\n            return \"top\" === this.options.position || \"bottom\" === this.options.position;\n          },\n          isFullWidth: function () {\n            return this.options.fullWidth;\n          },\n          getRightValue: function a(t) {\n            return null === t || \"undefined\" == typeof t ? NaN : \"number\" == typeof t && isNaN(t) ? NaN : \"object\" == typeof t ? t instanceof Date || t.isValid ? t : a(this.isHorizontal() ? t.x : t.y) : t;\n          },\n          getLabelForIndex: e.noop,\n          getPixelForValue: e.noop,\n          getValueForPixel: e.noop,\n          getPixelForTick: function (t, e) {\n            var a = this;\n            if (a.isHorizontal()) {\n              var i = a.width - (a.paddingLeft + a.paddingRight),\n                n = i / Math.max(a.ticks.length - (a.options.gridLines.offsetGridLines ? 0 : 1), 1),\n                o = n * t + a.paddingLeft;\n              e && (o += n / 2);\n              var r = a.left + Math.round(o);\n              return r += a.isFullWidth() ? a.margins.left : 0;\n            }\n            var l = a.height - (a.paddingTop + a.paddingBottom);\n            return a.top + t * (l / (a.ticks.length - 1));\n          },\n          getPixelForDecimal: function (t) {\n            var e = this;\n            if (e.isHorizontal()) {\n              var a = e.width - (e.paddingLeft + e.paddingRight),\n                i = a * t + e.paddingLeft,\n                n = e.left + Math.round(i);\n              return n += e.isFullWidth() ? e.margins.left : 0;\n            }\n            return e.top + t * e.height;\n          },\n          getBasePixel: function () {\n            var t = this,\n              e = t.min,\n              a = t.max;\n            return t.getPixelForValue(t.beginAtZero ? 0 : 0 > e && 0 > a ? a : e > 0 && a > 0 ? e : 0);\n          },\n          draw: function (a) {\n            var i = this,\n              n = i.options;\n            if (n.display) {\n              var o,\n                r,\n                l = i.ctx,\n                s = t.defaults.global,\n                d = n.ticks,\n                u = n.gridLines,\n                c = n.scaleLabel,\n                h = 0 !== i.labelRotation,\n                f = d.autoSkip,\n                g = i.isHorizontal();\n              d.maxTicksLimit && (r = d.maxTicksLimit);\n              var p = e.getValueOrDefault(d.fontColor, s.defaultFontColor),\n                m = e.getValueOrDefault(d.fontSize, s.defaultFontSize),\n                b = e.getValueOrDefault(d.fontStyle, s.defaultFontStyle),\n                v = e.getValueOrDefault(d.fontFamily, s.defaultFontFamily),\n                x = e.fontString(m, b, v),\n                y = u.tickMarkLength,\n                k = e.getValueOrDefault(c.fontColor, s.defaultFontColor),\n                S = e.getValueOrDefault(c.fontSize, s.defaultFontSize),\n                w = e.getValueOrDefault(c.fontStyle, s.defaultFontStyle),\n                C = e.getValueOrDefault(c.fontFamily, s.defaultFontFamily),\n                M = e.fontString(S, w, C),\n                D = e.toRadians(i.labelRotation),\n                A = Math.cos(D),\n                I = (Math.sin(D), i.longestLabelWidth * A);\n              l.fillStyle = p;\n              var F = [];\n              if (g) {\n                if (o = !1, h && (I /= 2), (I + d.autoSkipPadding) * i.ticks.length > i.width - (i.paddingLeft + i.paddingRight) && (o = 1 + Math.floor((I + d.autoSkipPadding) * i.ticks.length / (i.width - (i.paddingLeft + i.paddingRight)))), r && i.ticks.length > r) for (; !o || i.ticks.length / (o || 1) > r;) o || (o = 1), o += 1;\n                f || (o = !1);\n              }\n              var T = \"right\" === n.position ? i.left : i.right - y,\n                P = \"right\" === n.position ? i.left + y : i.right,\n                _ = \"bottom\" === n.position ? i.top : i.bottom - y,\n                R = \"bottom\" === n.position ? i.top + y : i.bottom;\n              if (e.each(i.ticks, function (t, r) {\n                if (void 0 !== t && null !== t) {\n                  var l = i.ticks.length === r + 1,\n                    s = o > 1 && r % o > 0 || r % o === 0 && r + o >= i.ticks.length;\n                  if ((!s || l) && void 0 !== t && null !== t) {\n                    var c, f;\n                    r === (\"undefined\" != typeof i.zeroLineIndex ? i.zeroLineIndex : 0) ? (c = u.zeroLineWidth, f = u.zeroLineColor) : (c = e.getValueAtIndexOrDefault(u.lineWidth, r), f = e.getValueAtIndexOrDefault(u.color, r));\n                    var p,\n                      m,\n                      b,\n                      v,\n                      x,\n                      k,\n                      S,\n                      w,\n                      C,\n                      M,\n                      A,\n                      I = \"middle\";\n                    if (g) {\n                      h || (I = \"top\" === n.position ? \"bottom\" : \"top\"), A = h ? \"right\" : \"center\";\n                      var V = i.getPixelForTick(r) + e.aliasPixel(c);\n                      C = i.getPixelForTick(r, u.offsetGridLines) + d.labelOffset, M = h ? i.top + 12 : \"top\" === n.position ? i.bottom - y : i.top + y, p = b = x = S = V, m = _, v = R, k = a.top, w = a.bottom;\n                    } else {\n                      \"left\" === n.position ? d.mirror ? (C = i.right + d.padding, A = \"left\") : (C = i.right - d.padding, A = \"right\") : d.mirror ? (C = i.left - d.padding, A = \"right\") : (C = i.left + d.padding, A = \"left\");\n                      var O = i.getPixelForTick(r);\n                      O += e.aliasPixel(c), M = i.getPixelForTick(r, u.offsetGridLines), p = T, b = P, x = a.left, S = a.right, m = v = k = w = O;\n                    }\n                    F.push({\n                      tx1: p,\n                      ty1: m,\n                      tx2: b,\n                      ty2: v,\n                      x1: x,\n                      y1: k,\n                      x2: S,\n                      y2: w,\n                      labelX: C,\n                      labelY: M,\n                      glWidth: c,\n                      glColor: f,\n                      rotation: -1 * D,\n                      label: t,\n                      textBaseline: I,\n                      textAlign: A\n                    });\n                  }\n                }\n              }), e.each(F, function (t) {\n                if (u.display && (l.lineWidth = t.glWidth, l.strokeStyle = t.glColor, l.beginPath(), u.drawTicks && (l.moveTo(t.tx1, t.ty1), l.lineTo(t.tx2, t.ty2)), u.drawOnChartArea && (l.moveTo(t.x1, t.y1), l.lineTo(t.x2, t.y2)), l.stroke()), d.display) {\n                  l.save(), l.translate(t.labelX, t.labelY), l.rotate(t.rotation), l.font = x, l.textBaseline = t.textBaseline, l.textAlign = t.textAlign;\n                  var a = t.label;\n                  if (e.isArray(a)) for (var i = 0, n = 0; i < a.length; ++i) l.fillText(\"\" + a[i], 0, n), n += 1.5 * m;else l.fillText(a, 0, 0);\n                  l.restore();\n                }\n              }), c.display) {\n                var V,\n                  O,\n                  L = 0;\n                if (g) V = i.left + (i.right - i.left) / 2, O = \"bottom\" === n.position ? i.bottom - S / 2 : i.top + S / 2;else {\n                  var B = \"left\" === n.position;\n                  V = B ? i.left + S / 2 : i.right - S / 2, O = i.top + (i.bottom - i.top) / 2, L = B ? -.5 * Math.PI : .5 * Math.PI;\n                }\n                l.save(), l.translate(V, O), l.rotate(L), l.textAlign = \"center\", l.textBaseline = \"middle\", l.fillStyle = k, l.font = M, l.fillText(c.labelString, 0, 0), l.restore();\n              }\n              if (u.drawBorder) {\n                l.lineWidth = e.getValueAtIndexOrDefault(u.lineWidth, 0), l.strokeStyle = e.getValueAtIndexOrDefault(u.color, 0);\n                var W = i.left,\n                  z = i.right,\n                  H = i.top,\n                  N = i.bottom,\n                  E = e.aliasPixel(l.lineWidth);\n                g ? (H = N = \"top\" === n.position ? i.bottom : i.top, H += E, N += E) : (W = z = \"left\" === n.position ? i.right : i.left, W += E, z += E), l.beginPath(), l.moveTo(W, H), l.lineTo(z, N), l.stroke();\n              }\n            }\n          }\n        });\n      };\n    }, {}],\n    31: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers;\n        t.scaleService = {\n          constructors: {},\n          defaults: {},\n          registerScaleType: function (t, a, i) {\n            this.constructors[t] = a, this.defaults[t] = e.clone(i);\n          },\n          getScaleConstructor: function (t) {\n            return this.constructors.hasOwnProperty(t) ? this.constructors[t] : void 0;\n          },\n          getScaleDefaults: function (a) {\n            return this.defaults.hasOwnProperty(a) ? e.scaleMerge(t.defaults.scale, this.defaults[a]) : {};\n          },\n          updateScaleDefaults: function (t, a) {\n            var i = this.defaults;\n            i.hasOwnProperty(t) && (i[t] = e.extend(i[t], a));\n          },\n          addScalesToLayout: function (a) {\n            e.each(a.scales, function (e) {\n              t.layoutService.addBox(a, e);\n            });\n          }\n        };\n      };\n    }, {}],\n    32: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers;\n        t.defaults.global.title = {\n          display: !1,\n          position: \"top\",\n          fullWidth: !0,\n          fontStyle: \"bold\",\n          padding: 10,\n          text: \"\"\n        };\n        var a = e.noop;\n        t.Title = t.Element.extend({\n          initialize: function (a) {\n            var i = this;\n            e.extend(i, a), i.options = e.configMerge(t.defaults.global.title, a.options), i.legendHitBoxes = [];\n          },\n          beforeUpdate: function () {\n            var a = this.chart.options;\n            a && a.title && (this.options = e.configMerge(t.defaults.global.title, a.title));\n          },\n          update: function (t, e, a) {\n            var i = this;\n            return i.beforeUpdate(), i.maxWidth = t, i.maxHeight = e, i.margins = a, i.beforeSetDimensions(), i.setDimensions(), i.afterSetDimensions(), i.beforeBuildLabels(), i.buildLabels(), i.afterBuildLabels(), i.beforeFit(), i.fit(), i.afterFit(), i.afterUpdate(), i.minSize;\n          },\n          afterUpdate: a,\n          beforeSetDimensions: a,\n          setDimensions: function () {\n            var t = this;\n            t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = {\n              width: 0,\n              height: 0\n            };\n          },\n          afterSetDimensions: a,\n          beforeBuildLabels: a,\n          buildLabels: a,\n          afterBuildLabels: a,\n          beforeFit: a,\n          fit: function () {\n            var a = this,\n              i = (a.ctx, e.getValueOrDefault),\n              n = a.options,\n              o = t.defaults.global,\n              r = n.display,\n              l = i(n.fontSize, o.defaultFontSize),\n              s = a.minSize;\n            a.isHorizontal() ? (s.width = a.maxWidth, s.height = r ? l + 2 * n.padding : 0) : (s.width = r ? l + 2 * n.padding : 0, s.height = a.maxHeight), a.width = s.width, a.height = s.height;\n          },\n          afterFit: a,\n          isHorizontal: function () {\n            var t = this.options.position;\n            return \"top\" === t || \"bottom\" === t;\n          },\n          draw: function () {\n            var a = this,\n              i = a.ctx,\n              n = e.getValueOrDefault,\n              o = a.options,\n              r = t.defaults.global;\n            if (o.display) {\n              var l,\n                s,\n                d = n(o.fontSize, r.defaultFontSize),\n                u = n(o.fontStyle, r.defaultFontStyle),\n                c = n(o.fontFamily, r.defaultFontFamily),\n                h = e.fontString(d, u, c),\n                f = 0,\n                g = a.top,\n                p = a.left,\n                m = a.bottom,\n                b = a.right;\n              i.fillStyle = n(o.fontColor, r.defaultFontColor), i.font = h, a.isHorizontal() ? (l = p + (b - p) / 2, s = g + (m - g) / 2) : (l = \"left\" === o.position ? p + d / 2 : b - d / 2, s = g + (m - g) / 2, f = Math.PI * (\"left\" === o.position ? -.5 : .5)), i.save(), i.translate(l, s), i.rotate(f), i.textAlign = \"center\", i.textBaseline = \"middle\", i.fillText(o.text, 0, 0), i.restore();\n            }\n          }\n        }), t.plugins.register({\n          beforeInit: function (e) {\n            var a = e.options,\n              i = a.title;\n            i && (e.titleBlock = new t.Title({\n              ctx: e.chart.ctx,\n              options: i,\n              chart: e\n            }), t.layoutService.addBox(e, e.titleBlock));\n          }\n        });\n      };\n    }, {}],\n    33: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        function e(t, e) {\n          return e && (n.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;\n        }\n        function a(t) {\n          if (!t.length) return !1;\n          var e,\n            a,\n            i = [],\n            n = [];\n          for (e = 0, a = t.length; a > e; ++e) {\n            var o = t[e];\n            if (o && o.hasValue()) {\n              var r = o.tooltipPosition();\n              i.push(r.x), n.push(r.y);\n            }\n          }\n          var l = 0,\n            s = 0;\n          for (e = 0, a - i.length; a > e; ++e) l += i[e], s += n[e];\n          return {\n            x: Math.round(l / i.length),\n            y: Math.round(s / i.length)\n          };\n        }\n        function i(t) {\n          var e = t._xScale,\n            a = t._yScale || t._scale,\n            i = t._index,\n            n = t._datasetIndex;\n          return {\n            xLabel: e ? e.getLabelForIndex(i, n) : \"\",\n            yLabel: a ? a.getLabelForIndex(i, n) : \"\",\n            index: i,\n            datasetIndex: n\n          };\n        }\n        var n = t.helpers;\n        t.defaults.global.tooltips = {\n          enabled: !0,\n          custom: null,\n          mode: \"single\",\n          backgroundColor: \"rgba(0,0,0,0.8)\",\n          titleFontStyle: \"bold\",\n          titleSpacing: 2,\n          titleMarginBottom: 6,\n          titleFontColor: \"#fff\",\n          titleAlign: \"left\",\n          bodySpacing: 2,\n          bodyFontColor: \"#fff\",\n          bodyAlign: \"left\",\n          footerFontStyle: \"bold\",\n          footerSpacing: 2,\n          footerMarginTop: 6,\n          footerFontColor: \"#fff\",\n          footerAlign: \"left\",\n          yPadding: 6,\n          xPadding: 6,\n          yAlign: \"center\",\n          xAlign: \"center\",\n          caretSize: 5,\n          cornerRadius: 6,\n          multiKeyBackground: \"#fff\",\n          callbacks: {\n            beforeTitle: n.noop,\n            title: function (t, e) {\n              var a = \"\",\n                i = e.labels,\n                n = i ? i.length : 0;\n              if (t.length > 0) {\n                var o = t[0];\n                o.xLabel ? a = o.xLabel : n > 0 && o.index < n && (a = i[o.index]);\n              }\n              return a;\n            },\n            afterTitle: n.noop,\n            beforeBody: n.noop,\n            beforeLabel: n.noop,\n            label: function (t, e) {\n              var a = e.datasets[t.datasetIndex].label || \"\";\n              return a + \": \" + t.yLabel;\n            },\n            labelColor: function (t, e) {\n              var a = e.getDatasetMeta(t.datasetIndex),\n                i = a.data[t.index],\n                n = i._view;\n              return {\n                borderColor: n.borderColor,\n                backgroundColor: n.backgroundColor\n              };\n            },\n            afterLabel: n.noop,\n            afterBody: n.noop,\n            beforeFooter: n.noop,\n            footer: n.noop,\n            afterFooter: n.noop\n          }\n        }, t.Tooltip = t.Element.extend({\n          initialize: function () {\n            var e = this,\n              a = t.defaults.global,\n              i = e._options,\n              o = n.getValueOrDefault;\n            n.extend(e, {\n              _model: {\n                xPadding: i.xPadding,\n                yPadding: i.yPadding,\n                xAlign: i.yAlign,\n                yAlign: i.xAlign,\n                bodyFontColor: i.bodyFontColor,\n                _bodyFontFamily: o(i.bodyFontFamily, a.defaultFontFamily),\n                _bodyFontStyle: o(i.bodyFontStyle, a.defaultFontStyle),\n                _bodyAlign: i.bodyAlign,\n                bodyFontSize: o(i.bodyFontSize, a.defaultFontSize),\n                bodySpacing: i.bodySpacing,\n                titleFontColor: i.titleFontColor,\n                _titleFontFamily: o(i.titleFontFamily, a.defaultFontFamily),\n                _titleFontStyle: o(i.titleFontStyle, a.defaultFontStyle),\n                titleFontSize: o(i.titleFontSize, a.defaultFontSize),\n                _titleAlign: i.titleAlign,\n                titleSpacing: i.titleSpacing,\n                titleMarginBottom: i.titleMarginBottom,\n                footerFontColor: i.footerFontColor,\n                _footerFontFamily: o(i.footerFontFamily, a.defaultFontFamily),\n                _footerFontStyle: o(i.footerFontStyle, a.defaultFontStyle),\n                footerFontSize: o(i.footerFontSize, a.defaultFontSize),\n                _footerAlign: i.footerAlign,\n                footerSpacing: i.footerSpacing,\n                footerMarginTop: i.footerMarginTop,\n                caretSize: i.caretSize,\n                cornerRadius: i.cornerRadius,\n                backgroundColor: i.backgroundColor,\n                opacity: 0,\n                legendColorBackground: i.multiKeyBackground\n              }\n            });\n          },\n          getTitle: function () {\n            var t = this,\n              a = t._options,\n              i = a.callbacks,\n              n = i.beforeTitle.apply(t, arguments),\n              o = i.title.apply(t, arguments),\n              r = i.afterTitle.apply(t, arguments),\n              l = [];\n            return l = e(l, n), l = e(l, o), l = e(l, r);\n          },\n          getBeforeBody: function () {\n            var t = this._options.callbacks.beforeBody.apply(this, arguments);\n            return n.isArray(t) ? t : void 0 !== t ? [t] : [];\n          },\n          getBody: function (t, a) {\n            var i = this,\n              o = i._options.callbacks,\n              r = [];\n            return n.each(t, function (t) {\n              var n = {\n                before: [],\n                lines: [],\n                after: []\n              };\n              e(n.before, o.beforeLabel.call(i, t, a)), e(n.lines, o.label.call(i, t, a)), e(n.after, o.afterLabel.call(i, t, a)), r.push(n);\n            }), r;\n          },\n          getAfterBody: function () {\n            var t = this._options.callbacks.afterBody.apply(this, arguments);\n            return n.isArray(t) ? t : void 0 !== t ? [t] : [];\n          },\n          getFooter: function () {\n            var t = this,\n              a = t._options.callbacks,\n              i = a.beforeFooter.apply(t, arguments),\n              n = a.footer.apply(t, arguments),\n              o = a.afterFooter.apply(t, arguments),\n              r = [];\n            return r = e(r, i), r = e(r, n), r = e(r, o);\n          },\n          update: function (t) {\n            var e,\n              o,\n              r = this,\n              l = r._options,\n              s = r._model,\n              d = r._active,\n              u = r._data,\n              c = r._chartInstance;\n            if (d.length) {\n              s.opacity = 1;\n              var h = [],\n                f = a(d),\n                g = [];\n              for (e = 0, o = d.length; o > e; ++e) g.push(i(d[e]));\n              l.itemSort && (g = g.sort(l.itemSort)), d.length > 1 && n.each(g, function (t) {\n                h.push(l.callbacks.labelColor.call(r, t, c));\n              }), n.extend(s, {\n                title: r.getTitle(g, u),\n                beforeBody: r.getBeforeBody(g, u),\n                body: r.getBody(g, u),\n                afterBody: r.getAfterBody(g, u),\n                footer: r.getFooter(g, u),\n                x: Math.round(f.x),\n                y: Math.round(f.y),\n                caretPadding: n.getValueOrDefault(f.padding, 2),\n                labelColors: h\n              });\n              var p = r.getTooltipSize(s);\n              r.determineAlignment(p), n.extend(s, r.getBackgroundPoint(s, p));\n            } else r._model.opacity = 0;\n            return t && l.custom && l.custom.call(r, s), r;\n          },\n          getTooltipSize: function (t) {\n            var e = this._chart.ctx,\n              a = {\n                height: 2 * t.yPadding,\n                width: 0\n              },\n              i = t.body,\n              o = i.reduce(function (t, e) {\n                return t + e.before.length + e.lines.length + e.after.length;\n              }, 0);\n            o += t.beforeBody.length + t.afterBody.length;\n            var r = t.title.length,\n              l = t.footer.length,\n              s = t.titleFontSize,\n              d = t.bodyFontSize,\n              u = t.footerFontSize;\n            a.height += r * s, a.height += (r - 1) * t.titleSpacing, a.height += r ? t.titleMarginBottom : 0, a.height += o * d, a.height += o ? (o - 1) * t.bodySpacing : 0, a.height += l ? t.footerMarginTop : 0, a.height += l * u, a.height += l ? (l - 1) * t.footerSpacing : 0;\n            var c = 0,\n              h = function (t) {\n                a.width = Math.max(a.width, e.measureText(t).width + c);\n              };\n            return e.font = n.fontString(s, t._titleFontStyle, t._titleFontFamily), n.each(t.title, h), e.font = n.fontString(d, t._bodyFontStyle, t._bodyFontFamily), n.each(t.beforeBody.concat(t.afterBody), h), c = i.length > 1 ? d + 2 : 0, n.each(i, function (t) {\n              n.each(t.before, h), n.each(t.lines, h), n.each(t.after, h);\n            }), c = 0, e.font = n.fontString(u, t._footerFontStyle, t._footerFontFamily), n.each(t.footer, h), a.width += 2 * t.xPadding, a;\n          },\n          determineAlignment: function (t) {\n            var e = this,\n              a = e._model,\n              i = e._chart,\n              n = e._chartInstance.chartArea;\n            a.y < t.height ? a.yAlign = \"top\" : a.y > i.height - t.height && (a.yAlign = \"bottom\");\n            var o,\n              r,\n              l,\n              s,\n              d,\n              u = (n.left + n.right) / 2,\n              c = (n.top + n.bottom) / 2;\n            \"center\" === a.yAlign ? (o = function (t) {\n              return u >= t;\n            }, r = function (t) {\n              return t > u;\n            }) : (o = function (e) {\n              return e <= t.width / 2;\n            }, r = function (e) {\n              return e >= i.width - t.width / 2;\n            }), l = function (e) {\n              return e + t.width > i.width;\n            }, s = function (e) {\n              return e - t.width < 0;\n            }, d = function (t) {\n              return c >= t ? \"top\" : \"bottom\";\n            }, o(a.x) ? (a.xAlign = \"left\", l(a.x) && (a.xAlign = \"center\", a.yAlign = d(a.y))) : r(a.x) && (a.xAlign = \"right\", s(a.x) && (a.xAlign = \"center\", a.yAlign = d(a.y)));\n          },\n          getBackgroundPoint: function (t, e) {\n            var a = {\n                x: t.x,\n                y: t.y\n              },\n              i = t.caretSize,\n              n = t.caretPadding,\n              o = t.cornerRadius,\n              r = t.xAlign,\n              l = t.yAlign,\n              s = i + n,\n              d = o + n;\n            return \"right\" === r ? a.x -= e.width : \"center\" === r && (a.x -= e.width / 2), \"top\" === l ? a.y += s : \"bottom\" === l ? a.y -= e.height + s : a.y -= e.height / 2, \"center\" === l ? \"left\" === r ? a.x += s : \"right\" === r && (a.x -= s) : \"left\" === r ? a.x -= d : \"right\" === r && (a.x += d), a;\n          },\n          drawCaret: function (t, e, a, i) {\n            var o,\n              r,\n              l,\n              s,\n              d,\n              u,\n              c = this._view,\n              h = this._chart.ctx,\n              f = c.caretSize,\n              g = c.cornerRadius,\n              p = c.xAlign,\n              m = c.yAlign,\n              b = t.x,\n              v = t.y,\n              x = e.width,\n              y = e.height;\n            \"center\" === m ? (\"left\" === p ? (o = b, r = o - f, l = o) : (o = b + x, r = o + f, l = o), d = v + y / 2, s = d - f, u = d + f) : (\"left\" === p ? (o = b + g, r = o + f, l = r + f) : \"right\" === p ? (o = b + x - g, r = o - f, l = r - f) : (r = b + x / 2, o = r - f, l = r + f), \"top\" === m ? (s = v, d = s - f, u = s) : (s = v + y, d = s + f, u = s));\n            var k = n.color(c.backgroundColor);\n            h.fillStyle = k.alpha(a * k.alpha()).rgbString(), h.beginPath(), h.moveTo(o, s), h.lineTo(r, d), h.lineTo(l, u), h.closePath(), h.fill();\n          },\n          drawTitle: function (t, e, a, i) {\n            var o = e.title;\n            if (o.length) {\n              a.textAlign = e._titleAlign, a.textBaseline = \"top\";\n              var r = e.titleFontSize,\n                l = e.titleSpacing,\n                s = n.color(e.titleFontColor);\n              a.fillStyle = s.alpha(i * s.alpha()).rgbString(), a.font = n.fontString(r, e._titleFontStyle, e._titleFontFamily);\n              var d, u;\n              for (d = 0, u = o.length; u > d; ++d) a.fillText(o[d], t.x, t.y), t.y += r + l, d + 1 === o.length && (t.y += e.titleMarginBottom - l);\n            }\n          },\n          drawBody: function (t, e, a, i) {\n            var o = e.bodyFontSize,\n              r = e.bodySpacing,\n              l = e.body;\n            a.textAlign = e._bodyAlign, a.textBaseline = \"top\";\n            var s = n.color(e.bodyFontColor),\n              d = s.alpha(i * s.alpha()).rgbString();\n            a.fillStyle = d, a.font = n.fontString(o, e._bodyFontStyle, e._bodyFontFamily);\n            var u = 0,\n              c = function (e) {\n                a.fillText(e, t.x + u, t.y), t.y += o + r;\n              };\n            n.each(e.beforeBody, c);\n            var h = l.length > 1;\n            u = h ? o + 2 : 0, n.each(l, function (r, l) {\n              n.each(r.before, c), n.each(r.lines, function (r) {\n                h && (a.fillStyle = n.color(e.legendColorBackground).alpha(i).rgbaString(), a.fillRect(t.x, t.y, o, o), a.strokeStyle = n.color(e.labelColors[l].borderColor).alpha(i).rgbaString(), a.strokeRect(t.x, t.y, o, o), a.fillStyle = n.color(e.labelColors[l].backgroundColor).alpha(i).rgbaString(), a.fillRect(t.x + 1, t.y + 1, o - 2, o - 2), a.fillStyle = d), c(r);\n              }), n.each(r.after, c);\n            }), u = 0, n.each(e.afterBody, c), t.y -= r;\n          },\n          drawFooter: function (t, e, a, i) {\n            var o = e.footer;\n            if (o.length) {\n              t.y += e.footerMarginTop, a.textAlign = e._footerAlign, a.textBaseline = \"top\";\n              var r = n.color(e.footerFontColor);\n              a.fillStyle = r.alpha(i * r.alpha()).rgbString(), a.font = n.fontString(e.footerFontSize, e._footerFontStyle, e._footerFontFamily), n.each(o, function (i) {\n                a.fillText(i, t.x, t.y), t.y += e.footerFontSize + e.footerSpacing;\n              });\n            }\n          },\n          draw: function () {\n            var t = this._chart.ctx,\n              e = this._view;\n            if (0 !== e.opacity) {\n              var a = this.getTooltipSize(e),\n                i = {\n                  x: e.x,\n                  y: e.y\n                },\n                o = Math.abs(e.opacity < .001) ? 0 : e.opacity;\n              if (this._options.enabled) {\n                var r = n.color(e.backgroundColor);\n                t.fillStyle = r.alpha(o * r.alpha()).rgbString(), n.drawRoundedRectangle(t, i.x, i.y, a.width, a.height, e.cornerRadius), t.fill(), this.drawCaret(i, a, o, e.caretPadding), i.x += e.xPadding, i.y += e.yPadding, this.drawTitle(i, e, t, o), this.drawBody(i, e, t, o), this.drawFooter(i, e, t, o);\n              }\n            }\n          }\n        });\n      };\n    }, {}],\n    34: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t, e) {\n        var a = t.helpers,\n          i = t.defaults.global;\n        i.elements.arc = {\n          backgroundColor: i.defaultColor,\n          borderColor: \"#fff\",\n          borderWidth: 2\n        }, t.elements.Arc = t.Element.extend({\n          inLabelRange: function (t) {\n            var e = this._view;\n            return e ? Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hoverRadius, 2) : !1;\n          },\n          inRange: function (t, e) {\n            var i = this._view;\n            if (i) {\n              for (var n = a.getAngleFromPoint(i, {\n                  x: t,\n                  y: e\n                }), o = n.angle, r = n.distance, l = i.startAngle, s = i.endAngle; l > s;) s += 2 * Math.PI;\n              for (; o > s;) o -= 2 * Math.PI;\n              for (; l > o;) o += 2 * Math.PI;\n              var d = o >= l && s >= o,\n                u = r >= i.innerRadius && r <= i.outerRadius;\n              return d && u;\n            }\n            return !1;\n          },\n          tooltipPosition: function () {\n            var t = this._view,\n              e = t.startAngle + (t.endAngle - t.startAngle) / 2,\n              a = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius;\n            return {\n              x: t.x + Math.cos(e) * a,\n              y: t.y + Math.sin(e) * a\n            };\n          },\n          draw: function () {\n            var t = this._chart.ctx,\n              e = this._view,\n              a = e.startAngle,\n              i = e.endAngle;\n            t.beginPath(), t.arc(e.x, e.y, e.outerRadius, a, i), t.arc(e.x, e.y, e.innerRadius, i, a, !0), t.closePath(), t.strokeStyle = e.borderColor, t.lineWidth = e.borderWidth, t.fillStyle = e.backgroundColor, t.fill(), t.lineJoin = \"bevel\", e.borderWidth && t.stroke();\n          }\n        });\n      };\n    }, {}],\n    35: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers,\n          a = t.defaults.global;\n        t.defaults.global.elements.line = {\n          tension: .4,\n          backgroundColor: a.defaultColor,\n          borderWidth: 3,\n          borderColor: a.defaultColor,\n          borderCapStyle: \"butt\",\n          borderDash: [],\n          borderDashOffset: 0,\n          borderJoinStyle: \"miter\",\n          fill: !0\n        }, t.elements.Line = t.Element.extend({\n          lineToNextPoint: function (t, e, a, i, n) {\n            var o = this,\n              r = o._chart.ctx,\n              l = o._view ? o._view.spanGaps : !1;\n            e._view.skip && !l ? i.call(o, t, e, a) : t._view.skip && !l ? n.call(o, t, e, a) : 0 === e._view.tension ? r.lineTo(e._view.x, e._view.y) : r.bezierCurveTo(t._view.controlPointNextX, t._view.controlPointNextY, e._view.controlPointPreviousX, e._view.controlPointPreviousY, e._view.x, e._view.y);\n          },\n          draw: function () {\n            function t(t) {\n              r._view.skip || l._view.skip ? t && o.lineTo(i._view.scaleZero.x, i._view.scaleZero.y) : o.bezierCurveTo(l._view.controlPointNextX, l._view.controlPointNextY, r._view.controlPointPreviousX, r._view.controlPointPreviousY, r._view.x, r._view.y);\n            }\n            var i = this,\n              n = i._view,\n              o = i._chart.ctx,\n              r = i._children[0],\n              l = i._children[i._children.length - 1];\n            o.save(), i._children.length > 0 && n.fill && (o.beginPath(), e.each(i._children, function (t, a) {\n              var r = e.previousItem(i._children, a),\n                l = e.nextItem(i._children, a);\n              0 === a ? (i._loop ? o.moveTo(n.scaleZero.x, n.scaleZero.y) : o.moveTo(t._view.x, n.scaleZero), t._view.skip ? i._loop || o.moveTo(l._view.x, i._view.scaleZero) : o.lineTo(t._view.x, t._view.y)) : i.lineToNextPoint(r, t, l, function (t, e, a) {\n                i._loop ? o.lineTo(i._view.scaleZero.x, i._view.scaleZero.y) : (o.lineTo(t._view.x, i._view.scaleZero), o.moveTo(a._view.x, i._view.scaleZero));\n              }, function (t, e) {\n                o.lineTo(e._view.x, e._view.y);\n              });\n            }, i), i._loop ? t(!0) : (o.lineTo(i._children[i._children.length - 1]._view.x, n.scaleZero), o.lineTo(i._children[0]._view.x, n.scaleZero)), o.fillStyle = n.backgroundColor || a.defaultColor, o.closePath(), o.fill());\n            var s = a.elements.line;\n            o.lineCap = n.borderCapStyle || s.borderCapStyle, o.setLineDash && o.setLineDash(n.borderDash || s.borderDash), o.lineDashOffset = n.borderDashOffset || s.borderDashOffset, o.lineJoin = n.borderJoinStyle || s.borderJoinStyle, o.lineWidth = n.borderWidth || s.borderWidth, o.strokeStyle = n.borderColor || a.defaultColor, o.beginPath(), e.each(i._children, function (t, a) {\n              var n = e.previousItem(i._children, a),\n                r = e.nextItem(i._children, a);\n              0 === a ? o.moveTo(t._view.x, t._view.y) : i.lineToNextPoint(n, t, r, function (t, e, a) {\n                o.moveTo(a._view.x, a._view.y);\n              }, function (t, e) {\n                o.moveTo(e._view.x, e._view.y);\n              });\n            }, i), i._loop && i._children.length > 0 && t(), o.stroke(), o.restore();\n          }\n        });\n      };\n    }, {}],\n    36: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers,\n          a = t.defaults.global,\n          i = a.defaultColor;\n        a.elements.point = {\n          radius: 3,\n          pointStyle: \"circle\",\n          backgroundColor: i,\n          borderWidth: 1,\n          borderColor: i,\n          hitRadius: 1,\n          hoverRadius: 4,\n          hoverBorderWidth: 1\n        }, t.elements.Point = t.Element.extend({\n          inRange: function (t, e) {\n            var a = this._view;\n            return a ? Math.pow(t - a.x, 2) + Math.pow(e - a.y, 2) < Math.pow(a.hitRadius + a.radius, 2) : !1;\n          },\n          inLabelRange: function (t) {\n            var e = this._view;\n            return e ? Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hitRadius, 2) : !1;\n          },\n          tooltipPosition: function () {\n            var t = this._view;\n            return {\n              x: t.x,\n              y: t.y,\n              padding: t.radius + t.borderWidth\n            };\n          },\n          draw: function () {\n            var t,\n              n,\n              o,\n              r,\n              l,\n              s,\n              d = this._view,\n              u = this._chart.ctx,\n              c = d.pointStyle,\n              h = d.radius,\n              f = d.x,\n              g = d.y;\n            if (!d.skip) {\n              if (\"object\" == typeof c && (t = c.toString(), \"[object HTMLImageElement]\" === t || \"[object HTMLCanvasElement]\" === t)) return void u.drawImage(c, f - c.width / 2, g - c.height / 2);\n              if (!(isNaN(h) || 0 >= h)) {\n                switch (u.strokeStyle = d.borderColor || i, u.lineWidth = e.getValueOrDefault(d.borderWidth, a.elements.point.borderWidth), u.fillStyle = d.backgroundColor || i, c) {\n                  default:\n                    u.beginPath(), u.arc(f, g, h, 0, 2 * Math.PI), u.closePath(), u.fill();\n                    break;\n                  case \"triangle\":\n                    u.beginPath(), n = 3 * h / Math.sqrt(3), l = n * Math.sqrt(3) / 2, u.moveTo(f - n / 2, g + l / 3), u.lineTo(f + n / 2, g + l / 3), u.lineTo(f, g - 2 * l / 3), u.closePath(), u.fill();\n                    break;\n                  case \"rect\":\n                    s = 1 / Math.SQRT2 * h, u.fillRect(f - s, g - s, 2 * s, 2 * s), u.strokeRect(f - s, g - s, 2 * s, 2 * s);\n                    break;\n                  case \"rectRot\":\n                    s = 1 / Math.SQRT2 * h, u.beginPath(), u.moveTo(f - s, g), u.lineTo(f, g + s), u.lineTo(f + s, g), u.lineTo(f, g - s), u.closePath(), u.fill();\n                    break;\n                  case \"cross\":\n                    u.beginPath(), u.moveTo(f, g + h), u.lineTo(f, g - h), u.moveTo(f - h, g), u.lineTo(f + h, g), u.closePath();\n                    break;\n                  case \"crossRot\":\n                    u.beginPath(), o = Math.cos(Math.PI / 4) * h, r = Math.sin(Math.PI / 4) * h, u.moveTo(f - o, g - r), u.lineTo(f + o, g + r), u.moveTo(f - o, g + r), u.lineTo(f + o, g - r), u.closePath();\n                    break;\n                  case \"star\":\n                    u.beginPath(), u.moveTo(f, g + h), u.lineTo(f, g - h), u.moveTo(f - h, g), u.lineTo(f + h, g), o = Math.cos(Math.PI / 4) * h, r = Math.sin(Math.PI / 4) * h, u.moveTo(f - o, g - r), u.lineTo(f + o, g + r), u.moveTo(f - o, g + r), u.lineTo(f + o, g - r), u.closePath();\n                    break;\n                  case \"line\":\n                    u.beginPath(), u.moveTo(f - h, g), u.lineTo(f + h, g), u.closePath();\n                    break;\n                  case \"dash\":\n                    u.beginPath(), u.moveTo(f, g), u.lineTo(f + h, g), u.closePath();\n                }\n                u.stroke();\n              }\n            }\n          }\n        });\n      };\n    }, {}],\n    37: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = (t.helpers, t.defaults.global);\n        e.elements.rectangle = {\n          backgroundColor: e.defaultColor,\n          borderWidth: 0,\n          borderColor: e.defaultColor,\n          borderSkipped: \"bottom\"\n        }, t.elements.Rectangle = t.Element.extend({\n          draw: function () {\n            function t(t) {\n              return s[(u + t) % 4];\n            }\n            var e = this._chart.ctx,\n              a = this._view,\n              i = a.width / 2,\n              n = a.x - i,\n              o = a.x + i,\n              r = a.base - (a.base - a.y),\n              l = a.borderWidth / 2;\n            a.borderWidth && (n += l, o -= l, r += l), e.beginPath(), e.fillStyle = a.backgroundColor, e.strokeStyle = a.borderColor, e.lineWidth = a.borderWidth;\n            var s = [[n, a.base], [n, r], [o, r], [o, a.base]],\n              d = [\"bottom\", \"left\", \"top\", \"right\"],\n              u = d.indexOf(a.borderSkipped, 0);\n            -1 === u && (u = 0), e.moveTo.apply(e, t(0));\n            for (var c = 1; 4 > c; c++) e.lineTo.apply(e, t(c));\n            e.fill(), a.borderWidth && e.stroke();\n          },\n          height: function () {\n            var t = this._view;\n            return t.base - t.y;\n          },\n          inRange: function (t, e) {\n            var a = this._view;\n            return a ? a.y < a.base ? t >= a.x - a.width / 2 && t <= a.x + a.width / 2 && e >= a.y && e <= a.base : t >= a.x - a.width / 2 && t <= a.x + a.width / 2 && e >= a.base && e <= a.y : !1;\n          },\n          inLabelRange: function (t) {\n            var e = this._view;\n            return e ? t >= e.x - e.width / 2 && t <= e.x + e.width / 2 : !1;\n          },\n          tooltipPosition: function () {\n            var t = this._view;\n            return {\n              x: t.x,\n              y: t.y\n            };\n          }\n        });\n      };\n    }, {}],\n    38: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers,\n          a = {\n            position: \"bottom\"\n          },\n          i = t.Scale.extend({\n            determineDataLimits: function () {\n              var t = this;\n              t.minIndex = 0, t.maxIndex = t.chart.data.labels.length - 1;\n              var a;\n              void 0 !== t.options.ticks.min && (a = e.indexOf(t.chart.data.labels, t.options.ticks.min), t.minIndex = -1 !== a ? a : t.minIndex), void 0 !== t.options.ticks.max && (a = e.indexOf(t.chart.data.labels, t.options.ticks.max), t.maxIndex = -1 !== a ? a : t.maxIndex), t.min = t.chart.data.labels[t.minIndex], t.max = t.chart.data.labels[t.maxIndex];\n            },\n            buildTicks: function (t) {\n              var e = this;\n              e.ticks = 0 === e.minIndex && e.maxIndex === e.chart.data.labels.length - 1 ? e.chart.data.labels : e.chart.data.labels.slice(e.minIndex, e.maxIndex + 1);\n            },\n            getLabelForIndex: function (t, e) {\n              return this.ticks[t];\n            },\n            getPixelForValue: function (t, e, a, i) {\n              var n = this,\n                o = Math.max(n.maxIndex + 1 - n.minIndex - (n.options.gridLines.offsetGridLines ? 0 : 1), 1);\n              if (n.isHorizontal()) {\n                var r = n.width - (n.paddingLeft + n.paddingRight),\n                  l = r / o,\n                  s = l * (e - n.minIndex) + n.paddingLeft;\n                return n.options.gridLines.offsetGridLines && i && (s += l / 2), n.left + Math.round(s);\n              }\n              var d = n.height - (n.paddingTop + n.paddingBottom),\n                u = d / o,\n                c = u * (e - n.minIndex) + n.paddingTop;\n              return n.options.gridLines.offsetGridLines && i && (c += u / 2), n.top + Math.round(c);\n            },\n            getPixelForTick: function (t, e) {\n              return this.getPixelForValue(this.ticks[t], t + this.minIndex, null, e);\n            },\n            getValueForPixel: function (t) {\n              var e,\n                a = this,\n                i = Math.max(a.ticks.length - (a.options.gridLines.offsetGridLines ? 0 : 1), 1),\n                n = a.isHorizontal(),\n                o = n ? a.width - (a.paddingLeft + a.paddingRight) : a.height - (a.paddingTop + a.paddingBottom),\n                r = o / i;\n              return a.options.gridLines.offsetGridLines && (t -= r / 2), t -= n ? a.paddingLeft : a.paddingTop, e = 0 >= t ? 0 : Math.round(t / r);\n            }\n          });\n        t.scaleService.registerScaleType(\"category\", i, a);\n      };\n    }, {}],\n    39: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers,\n          a = {\n            position: \"left\",\n            ticks: {\n              callback: function (t, a, i) {\n                var n = i.length > 3 ? i[2] - i[1] : i[1] - i[0];\n                Math.abs(n) > 1 && t !== Math.floor(t) && (n = t - Math.floor(t));\n                var o = e.log10(Math.abs(n)),\n                  r = \"\";\n                if (0 !== t) {\n                  var l = -1 * Math.floor(o);\n                  l = Math.max(Math.min(l, 20), 0), r = t.toFixed(l);\n                } else r = \"0\";\n                return r;\n              }\n            }\n          },\n          i = t.LinearScaleBase.extend({\n            determineDataLimits: function () {\n              function t(t) {\n                return l ? t.xAxisID === a.id : t.yAxisID === a.id;\n              }\n              var a = this,\n                i = a.options,\n                n = (i.ticks, a.chart),\n                o = n.data,\n                r = o.datasets,\n                l = a.isHorizontal();\n              if (a.min = null, a.max = null, i.stacked) {\n                var s = {},\n                  d = !1,\n                  u = !1;\n                e.each(r, function (o, r) {\n                  var l = n.getDatasetMeta(r);\n                  void 0 === s[l.type] && (s[l.type] = {\n                    positiveValues: [],\n                    negativeValues: []\n                  });\n                  var c = s[l.type].positiveValues,\n                    h = s[l.type].negativeValues;\n                  n.isDatasetVisible(r) && t(l) && e.each(o.data, function (t, e) {\n                    var n = +a.getRightValue(t);\n                    isNaN(n) || l.data[e].hidden || (c[e] = c[e] || 0, h[e] = h[e] || 0, i.relativePoints ? c[e] = 100 : 0 > n ? (u = !0, h[e] += n) : (d = !0, c[e] += n));\n                  });\n                }), e.each(s, function (t) {\n                  var i = t.positiveValues.concat(t.negativeValues),\n                    n = e.min(i),\n                    o = e.max(i);\n                  a.min = null === a.min ? n : Math.min(a.min, n), a.max = null === a.max ? o : Math.max(a.max, o);\n                });\n              } else e.each(r, function (i, o) {\n                var r = n.getDatasetMeta(o);\n                n.isDatasetVisible(o) && t(r) && e.each(i.data, function (t, e) {\n                  var i = +a.getRightValue(t);\n                  isNaN(i) || r.data[e].hidden || (null === a.min ? a.min = i : i < a.min && (a.min = i), null === a.max ? a.max = i : i > a.max && (a.max = i));\n                });\n              });\n              this.handleTickRangeOptions();\n            },\n            getTickLimit: function () {\n              var a,\n                i = this,\n                n = i.options.ticks;\n              if (i.isHorizontal()) a = Math.min(n.maxTicksLimit ? n.maxTicksLimit : 11, Math.ceil(i.width / 50));else {\n                var o = e.getValueOrDefault(n.fontSize, t.defaults.global.defaultFontSize);\n                a = Math.min(n.maxTicksLimit ? n.maxTicksLimit : 11, Math.ceil(i.height / (2 * o)));\n              }\n              return a;\n            },\n            handleDirectionalChanges: function () {\n              this.isHorizontal() || this.ticks.reverse();\n            },\n            getLabelForIndex: function (t, e) {\n              return +this.getRightValue(this.chart.data.datasets[e].data[t]);\n            },\n            getPixelForValue: function (t, e, a, i) {\n              var n,\n                o,\n                r = this,\n                l = r.paddingLeft,\n                s = r.paddingBottom,\n                d = r.start,\n                u = +r.getRightValue(t),\n                c = r.end - d;\n              return r.isHorizontal() ? (o = r.width - (l + r.paddingRight), n = r.left + o / c * (u - d), Math.round(n + l)) : (o = r.height - (r.paddingTop + s), n = r.bottom - s - o / c * (u - d), Math.round(n));\n            },\n            getValueForPixel: function (t) {\n              var e = this,\n                a = e.isHorizontal(),\n                i = e.paddingLeft,\n                n = e.paddingBottom,\n                o = a ? e.width - (i + e.paddingRight) : e.height - (e.paddingTop + n),\n                r = (a ? t - e.left - i : e.bottom - n - t) / o;\n              return e.start + (e.end - e.start) * r;\n            },\n            getPixelForTick: function (t, e) {\n              return this.getPixelForValue(this.ticksAsNumbers[t], null, null, e);\n            }\n          });\n        t.scaleService.registerScaleType(\"linear\", i, a);\n      };\n    }, {}],\n    40: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers,\n          a = e.noop;\n        t.LinearScaleBase = t.Scale.extend({\n          handleTickRangeOptions: function () {\n            var t = this,\n              a = t.options,\n              i = a.ticks;\n            if (i.beginAtZero) {\n              var n = e.sign(t.min),\n                o = e.sign(t.max);\n              0 > n && 0 > o ? t.max = 0 : n > 0 && o > 0 && (t.min = 0);\n            }\n            void 0 !== i.min ? t.min = i.min : void 0 !== i.suggestedMin && (t.min = Math.min(t.min, i.suggestedMin)), void 0 !== i.max ? t.max = i.max : void 0 !== i.suggestedMax && (t.max = Math.max(t.max, i.suggestedMax)), t.min === t.max && (t.max++, i.beginAtZero || t.min--);\n          },\n          getTickLimit: a,\n          handleDirectionalChanges: a,\n          buildTicks: function () {\n            var t = this,\n              a = t.options,\n              i = a.ticks,\n              n = e.getValueOrDefault,\n              o = (t.isHorizontal(), t.ticks = []),\n              r = t.getTickLimit();\n            r = Math.max(2, r);\n            var l,\n              s = i.fixedStepSize && i.fixedStepSize > 0 || i.stepSize && i.stepSize > 0;\n            if (s) l = n(i.fixedStepSize, i.stepSize);else {\n              var d = e.niceNum(t.max - t.min, !1);\n              l = e.niceNum(d / (r - 1), !0);\n            }\n            var u = Math.floor(t.min / l) * l,\n              c = Math.ceil(t.max / l) * l,\n              h = (c - u) / l;\n            h = e.almostEquals(h, Math.round(h), l / 1e3) ? Math.round(h) : Math.ceil(h), o.push(void 0 !== i.min ? i.min : u);\n            for (var f = 1; h > f; ++f) o.push(u + f * l);\n            o.push(void 0 !== i.max ? i.max : c), t.handleDirectionalChanges(), t.max = e.max(o), t.min = e.min(o), i.reverse ? (o.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max);\n          },\n          convertTicksToLabels: function () {\n            var e = this;\n            e.ticksAsNumbers = e.ticks.slice(), e.zeroLineIndex = e.ticks.indexOf(0), t.Scale.prototype.convertTicksToLabels.call(e);\n          }\n        });\n      };\n    }, {}],\n    41: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers,\n          a = {\n            position: \"left\",\n            ticks: {\n              callback: function (t, a, i) {\n                var n = t / Math.pow(10, Math.floor(e.log10(t)));\n                return 1 === n || 2 === n || 5 === n || 0 === a || a === i.length - 1 ? t.toExponential() : \"\";\n              }\n            }\n          },\n          i = t.Scale.extend({\n            determineDataLimits: function () {\n              function t(t) {\n                return d ? t.xAxisID === a.id : t.yAxisID === a.id;\n              }\n              var a = this,\n                i = a.options,\n                n = i.ticks,\n                o = a.chart,\n                r = o.data,\n                l = r.datasets,\n                s = e.getValueOrDefault,\n                d = a.isHorizontal();\n              if (a.min = null, a.max = null, i.stacked) {\n                var u = {};\n                e.each(l, function (n, r) {\n                  var l = o.getDatasetMeta(r);\n                  o.isDatasetVisible(r) && t(l) && (void 0 === u[l.type] && (u[l.type] = []), e.each(n.data, function (t, e) {\n                    var n = u[l.type],\n                      o = +a.getRightValue(t);\n                    isNaN(o) || l.data[e].hidden || (n[e] = n[e] || 0, i.relativePoints ? n[e] = 100 : n[e] += o);\n                  }));\n                }), e.each(u, function (t) {\n                  var i = e.min(t),\n                    n = e.max(t);\n                  a.min = null === a.min ? i : Math.min(a.min, i), a.max = null === a.max ? n : Math.max(a.max, n);\n                });\n              } else e.each(l, function (i, n) {\n                var r = o.getDatasetMeta(n);\n                o.isDatasetVisible(n) && t(r) && e.each(i.data, function (t, e) {\n                  var i = +a.getRightValue(t);\n                  isNaN(i) || r.data[e].hidden || (null === a.min ? a.min = i : i < a.min && (a.min = i), null === a.max ? a.max = i : i > a.max && (a.max = i));\n                });\n              });\n              a.min = s(n.min, a.min), a.max = s(n.max, a.max), a.min === a.max && (0 !== a.min && null !== a.min ? (a.min = Math.pow(10, Math.floor(e.log10(a.min)) - 1), a.max = Math.pow(10, Math.floor(e.log10(a.max)) + 1)) : (a.min = 1, a.max = 10));\n            },\n            buildTicks: function () {\n              for (var t = this, a = t.options, i = a.ticks, n = e.getValueOrDefault, o = t.ticks = [], r = n(i.min, Math.pow(10, Math.floor(e.log10(t.min)))); r < t.max;) {\n                o.push(r);\n                var l = Math.floor(e.log10(r)),\n                  s = Math.floor(r / Math.pow(10, l)) + 1;\n                10 === s && (s = 1, ++l), r = s * Math.pow(10, l);\n              }\n              var d = n(i.max, r);\n              o.push(d), t.isHorizontal() || o.reverse(), t.max = e.max(o), t.min = e.min(o), i.reverse ? (o.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max);\n            },\n            convertTicksToLabels: function () {\n              this.tickValues = this.ticks.slice(), t.Scale.prototype.convertTicksToLabels.call(this);\n            },\n            getLabelForIndex: function (t, e) {\n              return +this.getRightValue(this.chart.data.datasets[e].data[t]);\n            },\n            getPixelForTick: function (t, e) {\n              return this.getPixelForValue(this.tickValues[t], null, null, e);\n            },\n            getPixelForValue: function (t, a, i, n) {\n              var o,\n                r,\n                l = this,\n                s = l.start,\n                d = +l.getRightValue(t),\n                u = e.log10(l.end) - e.log10(s),\n                c = l.paddingTop,\n                h = l.paddingBottom,\n                f = l.paddingLeft;\n              return l.isHorizontal() ? 0 === d ? r = l.left + f : (o = l.width - (f + l.paddingRight), r = l.left + o / u * (e.log10(d) - e.log10(s)), r += f) : 0 === d ? r = l.top + c : (o = l.height - (c + h), r = l.bottom - h - o / u * (e.log10(d) - e.log10(s))), r;\n            },\n            getValueForPixel: function (t) {\n              var a,\n                i,\n                n = this,\n                o = e.log10(n.end) - e.log10(n.start);\n              return n.isHorizontal() ? (i = n.width - (n.paddingLeft + n.paddingRight), a = n.start * Math.pow(10, (t - n.left - n.paddingLeft) * o / i)) : (i = n.height - (n.paddingTop + n.paddingBottom), a = Math.pow(10, (n.bottom - n.paddingBottom - t) * o / i) / n.start), a;\n            }\n          });\n        t.scaleService.registerScaleType(\"logarithmic\", i, a);\n      };\n    }, {}],\n    42: [function (t, e, a) {\n      \"use strict\";\n\n      e.exports = function (t) {\n        var e = t.helpers,\n          a = t.defaults.global,\n          i = {\n            display: !0,\n            animate: !0,\n            lineArc: !1,\n            position: \"chartArea\",\n            angleLines: {\n              display: !0,\n              color: \"rgba(0, 0, 0, 0.1)\",\n              lineWidth: 1\n            },\n            ticks: {\n              showLabelBackdrop: !0,\n              backdropColor: \"rgba(255,255,255,0.75)\",\n              backdropPaddingY: 2,\n              backdropPaddingX: 2\n            },\n            pointLabels: {\n              fontSize: 10,\n              callback: function (t) {\n                return t;\n              }\n            }\n          },\n          n = t.LinearScaleBase.extend({\n            getValueCount: function () {\n              return this.chart.data.labels.length;\n            },\n            setDimensions: function () {\n              var t = this,\n                i = t.options,\n                n = i.ticks;\n              t.width = t.maxWidth, t.height = t.maxHeight, t.xCenter = Math.round(t.width / 2), t.yCenter = Math.round(t.height / 2);\n              var o = e.min([t.height, t.width]),\n                r = e.getValueOrDefault(n.fontSize, a.defaultFontSize);\n              t.drawingArea = i.display ? o / 2 - (r / 2 + n.backdropPaddingY) : o / 2;\n            },\n            determineDataLimits: function () {\n              var t = this,\n                a = t.chart;\n              t.min = null, t.max = null, e.each(a.data.datasets, function (i, n) {\n                if (a.isDatasetVisible(n)) {\n                  var o = a.getDatasetMeta(n);\n                  e.each(i.data, function (e, a) {\n                    var i = +t.getRightValue(e);\n                    isNaN(i) || o.data[a].hidden || (null === t.min ? t.min = i : i < t.min && (t.min = i), null === t.max ? t.max = i : i > t.max && (t.max = i));\n                  });\n                }\n              }), t.handleTickRangeOptions();\n            },\n            getTickLimit: function () {\n              var t = this.options.ticks,\n                i = e.getValueOrDefault(t.fontSize, a.defaultFontSize);\n              return Math.min(t.maxTicksLimit ? t.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * i)));\n            },\n            convertTicksToLabels: function () {\n              var e = this;\n              t.LinearScaleBase.prototype.convertTicksToLabels.call(e), e.pointLabels = e.chart.data.labels.map(e.options.pointLabels.callback, e);\n            },\n            getLabelForIndex: function (t, e) {\n              return +this.getRightValue(this.chart.data.datasets[e].data[t]);\n            },\n            fit: function () {\n              var t,\n                i,\n                n,\n                o,\n                r,\n                l,\n                s,\n                d,\n                u,\n                c,\n                h,\n                f,\n                g = this.options.pointLabels,\n                p = e.getValueOrDefault(g.fontSize, a.defaultFontSize),\n                m = e.getValueOrDefault(g.fontStyle, a.defaultFontStyle),\n                b = e.getValueOrDefault(g.fontFamily, a.defaultFontFamily),\n                v = e.fontString(p, m, b),\n                x = e.min([this.height / 2 - p - 5, this.width / 2]),\n                y = this.width,\n                k = 0;\n              for (this.ctx.font = v, i = 0; i < this.getValueCount(); i++) t = this.getPointPosition(i, x), n = this.ctx.measureText(this.pointLabels[i] ? this.pointLabels[i] : \"\").width + 5, 0 === i || i === this.getValueCount() / 2 ? (o = n / 2, t.x + o > y && (y = t.x + o, r = i), t.x - o < k && (k = t.x - o, s = i)) : i < this.getValueCount() / 2 ? t.x + n > y && (y = t.x + n, r = i) : i > this.getValueCount() / 2 && t.x - n < k && (k = t.x - n, s = i);\n              u = k, c = Math.ceil(y - this.width), l = this.getIndexAngle(r), d = this.getIndexAngle(s), h = c / Math.sin(l + Math.PI / 2), f = u / Math.sin(d + Math.PI / 2), h = e.isNumber(h) ? h : 0, f = e.isNumber(f) ? f : 0, this.drawingArea = Math.round(x - (f + h) / 2), this.setCenterPoint(f, h);\n            },\n            setCenterPoint: function (t, e) {\n              var a = this,\n                i = a.width - e - a.drawingArea,\n                n = t + a.drawingArea;\n              a.xCenter = Math.round((n + i) / 2 + a.left), a.yCenter = Math.round(a.height / 2 + a.top);\n            },\n            getIndexAngle: function (t) {\n              var e = 2 * Math.PI / this.getValueCount();\n              return t * e - Math.PI / 2;\n            },\n            getDistanceFromCenterForValue: function (t) {\n              var e = this;\n              if (null === t) return 0;\n              var a = e.drawingArea / (e.max - e.min);\n              return e.options.reverse ? (e.max - t) * a : (t - e.min) * a;\n            },\n            getPointPosition: function (t, e) {\n              var a = this,\n                i = a.getIndexAngle(t);\n              return {\n                x: Math.round(Math.cos(i) * e) + a.xCenter,\n                y: Math.round(Math.sin(i) * e) + a.yCenter\n              };\n            },\n            getPointPositionForValue: function (t, e) {\n              return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));\n            },\n            getBasePosition: function () {\n              var t = this,\n                e = t.min,\n                a = t.max;\n              return t.getPointPositionForValue(0, t.beginAtZero ? 0 : 0 > e && 0 > a ? a : e > 0 && a > 0 ? e : 0);\n            },\n            draw: function () {\n              var t = this,\n                i = t.options,\n                n = i.gridLines,\n                o = i.ticks,\n                r = i.angleLines,\n                l = i.pointLabels,\n                s = e.getValueOrDefault;\n              if (i.display) {\n                var d = t.ctx,\n                  u = s(o.fontSize, a.defaultFontSize),\n                  c = s(o.fontStyle, a.defaultFontStyle),\n                  h = s(o.fontFamily, a.defaultFontFamily),\n                  f = e.fontString(u, c, h);\n                if (e.each(t.ticks, function (r, l) {\n                  if (l > 0 || i.reverse) {\n                    var c = t.getDistanceFromCenterForValue(t.ticksAsNumbers[l]),\n                      h = t.yCenter - c;\n                    if (n.display && 0 !== l) if (d.strokeStyle = e.getValueAtIndexOrDefault(n.color, l - 1), d.lineWidth = e.getValueAtIndexOrDefault(n.lineWidth, l - 1), i.lineArc) d.beginPath(), d.arc(t.xCenter, t.yCenter, c, 0, 2 * Math.PI), d.closePath(), d.stroke();else {\n                      d.beginPath();\n                      for (var g = 0; g < t.getValueCount(); g++) {\n                        var p = t.getPointPosition(g, c);\n                        0 === g ? d.moveTo(p.x, p.y) : d.lineTo(p.x, p.y);\n                      }\n                      d.closePath(), d.stroke();\n                    }\n                    if (o.display) {\n                      var m = s(o.fontColor, a.defaultFontColor);\n                      if (d.font = f, o.showLabelBackdrop) {\n                        var b = d.measureText(r).width;\n                        d.fillStyle = o.backdropColor, d.fillRect(t.xCenter - b / 2 - o.backdropPaddingX, h - u / 2 - o.backdropPaddingY, b + 2 * o.backdropPaddingX, u + 2 * o.backdropPaddingY);\n                      }\n                      d.textAlign = \"center\", d.textBaseline = \"middle\", d.fillStyle = m, d.fillText(r, t.xCenter, h);\n                    }\n                  }\n                }), !i.lineArc) {\n                  d.lineWidth = r.lineWidth, d.strokeStyle = r.color;\n                  for (var g = t.getDistanceFromCenterForValue(i.reverse ? t.min : t.max), p = s(l.fontSize, a.defaultFontSize), m = s(l.fontStyle, a.defaultFontStyle), b = s(l.fontFamily, a.defaultFontFamily), v = e.fontString(p, m, b), x = t.getValueCount() - 1; x >= 0; x--) {\n                    if (r.display) {\n                      var y = t.getPointPosition(x, g);\n                      d.beginPath(), d.moveTo(t.xCenter, t.yCenter), d.lineTo(y.x, y.y), d.stroke(), d.closePath();\n                    }\n                    var k = t.getPointPosition(x, g + 5),\n                      S = s(l.fontColor, a.defaultFontColor);\n                    d.font = v, d.fillStyle = S;\n                    var w = t.pointLabels,\n                      C = w.length,\n                      M = w.length / 2,\n                      D = M / 2,\n                      A = D > x || x > C - D,\n                      I = x === D || x === C - D;\n                    0 === x ? d.textAlign = \"center\" : x === M ? d.textAlign = \"center\" : M > x ? d.textAlign = \"left\" : d.textAlign = \"right\", I ? d.textBaseline = \"middle\" : A ? d.textBaseline = \"bottom\" : d.textBaseline = \"top\", d.fillText(w[x] ? w[x] : \"\", k.x, k.y);\n                  }\n                }\n              }\n            }\n          });\n        t.scaleService.registerScaleType(\"radialLinear\", n, i);\n      };\n    }, {}],\n    43: [function (t, e, a) {\n      \"use strict\";\n\n      var i = t(1);\n      i = \"function\" == typeof i ? i : window.moment, e.exports = function (t) {\n        var e = t.helpers,\n          a = {\n            units: [{\n              name: \"millisecond\",\n              steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n            }, {\n              name: \"second\",\n              steps: [1, 2, 5, 10, 30]\n            }, {\n              name: \"minute\",\n              steps: [1, 2, 5, 10, 30]\n            }, {\n              name: \"hour\",\n              steps: [1, 2, 3, 6, 12]\n            }, {\n              name: \"day\",\n              steps: [1, 2, 5]\n            }, {\n              name: \"week\",\n              maxStep: 4\n            }, {\n              name: \"month\",\n              maxStep: 3\n            }, {\n              name: \"quarter\",\n              maxStep: 4\n            }, {\n              name: \"year\",\n              maxStep: !1\n            }]\n          },\n          n = {\n            position: \"bottom\",\n            time: {\n              parser: !1,\n              format: !1,\n              unit: !1,\n              round: !1,\n              displayFormat: !1,\n              isoWeekday: !1,\n              displayFormats: {\n                millisecond: \"h:mm:ss.SSS a\",\n                second: \"h:mm:ss a\",\n                minute: \"h:mm:ss a\",\n                hour: \"MMM D, hA\",\n                day: \"ll\",\n                week: \"ll\",\n                month: \"MMM YYYY\",\n                quarter: \"[Q]Q - YYYY\",\n                year: \"YYYY\"\n              }\n            },\n            ticks: {\n              autoSkip: !1\n            }\n          },\n          o = t.Scale.extend({\n            initialize: function () {\n              if (!i) throw new Error(\"Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com\");\n              t.Scale.prototype.initialize.call(this);\n            },\n            getLabelMoment: function (t, e) {\n              return this.labelMoments[t][e];\n            },\n            getMomentStartOf: function (t) {\n              var e = this;\n              return \"week\" === e.options.time.unit && e.options.time.isoWeekday !== !1 ? t.clone().startOf(\"isoWeek\").isoWeekday(e.options.time.isoWeekday) : t.clone().startOf(e.tickUnit);\n            },\n            determineDataLimits: function () {\n              var t = this;\n              t.labelMoments = [];\n              var a = [];\n              t.chart.data.labels && t.chart.data.labels.length > 0 ? (e.each(t.chart.data.labels, function (e, i) {\n                var n = t.parseTime(e);\n                n.isValid() && (t.options.time.round && n.startOf(t.options.time.round), a.push(n));\n              }, t), t.firstTick = i.min.call(t, a), t.lastTick = i.max.call(t, a)) : (t.firstTick = null, t.lastTick = null), e.each(t.chart.data.datasets, function (n, o) {\n                var r = [],\n                  l = t.chart.isDatasetVisible(o);\n                \"object\" == typeof n.data[0] && null !== n.data[0] ? e.each(n.data, function (e, a) {\n                  var n = t.parseTime(t.getRightValue(e));\n                  n.isValid() && (t.options.time.round && n.startOf(t.options.time.round), r.push(n), l && (t.firstTick = null !== t.firstTick ? i.min(t.firstTick, n) : n, t.lastTick = null !== t.lastTick ? i.max(t.lastTick, n) : n));\n                }, t) : r = a, t.labelMoments.push(r);\n              }, t), t.options.time.min && (t.firstTick = t.parseTime(t.options.time.min)), t.options.time.max && (t.lastTick = t.parseTime(t.options.time.max)), t.firstTick = (t.firstTick || i()).clone(), t.lastTick = (t.lastTick || i()).clone();\n            },\n            buildTicks: function (i) {\n              var n = this;\n              n.ctx.save();\n              var o = e.getValueOrDefault(n.options.ticks.fontSize, t.defaults.global.defaultFontSize),\n                r = e.getValueOrDefault(n.options.ticks.fontStyle, t.defaults.global.defaultFontStyle),\n                l = e.getValueOrDefault(n.options.ticks.fontFamily, t.defaults.global.defaultFontFamily),\n                s = e.fontString(o, r, l);\n              if (n.ctx.font = s, n.ticks = [], n.unitScale = 1, n.scaleSizeInUnits = 0, n.options.time.unit) n.tickUnit = n.options.time.unit || \"day\", n.displayFormat = n.options.time.displayFormats[n.tickUnit], n.scaleSizeInUnits = n.lastTick.diff(n.firstTick, n.tickUnit, !0), n.unitScale = e.getValueOrDefault(n.options.time.unitStepSize, 1);else {\n                var d = n.isHorizontal() ? n.width - (n.paddingLeft + n.paddingRight) : n.height - (n.paddingTop + n.paddingBottom),\n                  u = n.tickFormatFunction(n.firstTick, 0, []),\n                  c = n.ctx.measureText(u).width,\n                  h = Math.cos(e.toRadians(n.options.ticks.maxRotation)),\n                  f = Math.sin(e.toRadians(n.options.ticks.maxRotation));\n                c = c * h + o * f;\n                var g = d / c;\n                n.tickUnit = \"millisecond\", n.scaleSizeInUnits = n.lastTick.diff(n.firstTick, n.tickUnit, !0), n.displayFormat = n.options.time.displayFormats[n.tickUnit];\n                for (var p = 0, m = a.units[p]; p < a.units.length;) {\n                  if (n.unitScale = 1, e.isArray(m.steps) && Math.ceil(n.scaleSizeInUnits / g) < e.max(m.steps)) {\n                    for (var b = 0; b < m.steps.length; ++b) if (m.steps[b] >= Math.ceil(n.scaleSizeInUnits / g)) {\n                      n.unitScale = e.getValueOrDefault(n.options.time.unitStepSize, m.steps[b]);\n                      break;\n                    }\n                    break;\n                  }\n                  if (m.maxStep === !1 || Math.ceil(n.scaleSizeInUnits / g) < m.maxStep) {\n                    n.unitScale = e.getValueOrDefault(n.options.time.unitStepSize, Math.ceil(n.scaleSizeInUnits / g));\n                    break;\n                  }\n                  ++p, m = a.units[p], n.tickUnit = m.name;\n                  var v = n.firstTick.diff(n.getMomentStartOf(n.firstTick), n.tickUnit, !0),\n                    x = n.getMomentStartOf(n.lastTick.clone().add(1, n.tickUnit)).diff(n.lastTick, n.tickUnit, !0);\n                  n.scaleSizeInUnits = n.lastTick.diff(n.firstTick, n.tickUnit, !0) + v + x, n.displayFormat = n.options.time.displayFormats[m.name];\n                }\n              }\n              var y;\n              if (n.options.time.min ? y = n.getMomentStartOf(n.firstTick) : (n.firstTick = n.getMomentStartOf(n.firstTick), y = n.firstTick), !n.options.time.max) {\n                var k = n.getMomentStartOf(n.lastTick);\n                0 !== k.diff(n.lastTick, n.tickUnit, !0) && (n.lastTick = n.getMomentStartOf(n.lastTick.add(1, n.tickUnit)));\n              }\n              n.smallestLabelSeparation = n.width, e.each(n.chart.data.datasets, function (t, e) {\n                for (var a = 1; a < n.labelMoments[e].length; a++) n.smallestLabelSeparation = Math.min(n.smallestLabelSeparation, n.labelMoments[e][a].diff(n.labelMoments[e][a - 1], n.tickUnit, !0));\n              }, n), n.options.time.displayFormat && (n.displayFormat = n.options.time.displayFormat), n.ticks.push(n.firstTick.clone());\n              for (var S = 1; S <= n.scaleSizeInUnits; ++S) {\n                var w = y.clone().add(S, n.tickUnit);\n                if (n.options.time.max && w.diff(n.lastTick, n.tickUnit, !0) >= 0) break;\n                S % n.unitScale === 0 && n.ticks.push(w);\n              }\n              var C = n.ticks[n.ticks.length - 1].diff(n.lastTick, n.tickUnit);\n              (0 !== C || 0 === n.scaleSizeInUnits) && (n.options.time.max ? (n.ticks.push(n.lastTick.clone()), n.scaleSizeInUnits = n.lastTick.diff(n.ticks[0], n.tickUnit, !0)) : (n.ticks.push(n.lastTick.clone()), n.scaleSizeInUnits = n.lastTick.diff(n.firstTick, n.tickUnit, !0))), n.ctx.restore();\n            },\n            getLabelForIndex: function (t, e) {\n              var a = this,\n                i = a.chart.data.labels && t < a.chart.data.labels.length ? a.chart.data.labels[t] : \"\";\n              return \"object\" == typeof a.chart.data.datasets[e].data[0] && (i = a.getRightValue(a.chart.data.datasets[e].data[t])), a.options.time.tooltipFormat && (i = a.parseTime(i).format(a.options.time.tooltipFormat)), i;\n            },\n            tickFormatFunction: function (t, a, i) {\n              var n = t.format(this.displayFormat),\n                o = this.options.ticks,\n                r = e.getValueOrDefault(o.callback, o.userCallback);\n              return r ? r(n, a, i) : n;\n            },\n            convertTicksToLabels: function () {\n              var t = this;\n              t.tickMoments = t.ticks, t.ticks = t.ticks.map(t.tickFormatFunction, t);\n            },\n            getPixelForValue: function (t, e, a, i) {\n              var n = this,\n                o = t && t.isValid && t.isValid() ? t : n.getLabelMoment(a, e);\n              if (o) {\n                var r = o.diff(n.firstTick, n.tickUnit, !0),\n                  l = r / n.scaleSizeInUnits;\n                if (n.isHorizontal()) {\n                  var s = n.width - (n.paddingLeft + n.paddingRight),\n                    d = (s / Math.max(n.ticks.length - 1, 1), s * l + n.paddingLeft);\n                  return n.left + Math.round(d);\n                }\n                var u = n.height - (n.paddingTop + n.paddingBottom),\n                  c = (u / Math.max(n.ticks.length - 1, 1), u * l + n.paddingTop);\n                return n.top + Math.round(c);\n              }\n            },\n            getPixelForTick: function (t, e) {\n              return this.getPixelForValue(this.tickMoments[t], null, null, e);\n            },\n            getValueForPixel: function (t) {\n              var e = this,\n                a = e.isHorizontal() ? e.width - (e.paddingLeft + e.paddingRight) : e.height - (e.paddingTop + e.paddingBottom),\n                n = (t - (e.isHorizontal() ? e.left + e.paddingLeft : e.top + e.paddingTop)) / a;\n              return n *= e.scaleSizeInUnits, e.firstTick.clone().add(i.duration(n, e.tickUnit).asSeconds(), \"seconds\");\n            },\n            parseTime: function (t) {\n              var e = this;\n              return \"string\" == typeof e.options.time.parser ? i(t, e.options.time.parser) : \"function\" == typeof e.options.time.parser ? e.options.time.parser(t) : \"function\" == typeof t.getMonth || \"number\" == typeof t ? i(t) : t.isValid && t.isValid() ? t : \"string\" != typeof e.options.time.format && e.options.time.format.call ? (console.warn(\"options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale\"), e.options.time.format(t)) : i(t, e.options.time.format);\n            }\n          });\n        t.scaleService.registerScaleType(\"time\", o, n);\n      };\n    }, {\n      1: 1\n    }]\n  }, {}, [7])(7);\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}