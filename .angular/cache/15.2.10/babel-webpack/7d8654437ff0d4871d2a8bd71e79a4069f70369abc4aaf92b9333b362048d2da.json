{"ast":null,"code":"import PerfectScrollbar from 'perfect-scrollbar';\n// const ResizeObserver = require('resize-observer-polyfill');\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport { Subject, fromEvent } from 'rxjs';\nimport { auditTime, takeUntil } from 'rxjs/operators';\nimport { PLATFORM_ID } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { EventEmitter } from '@angular/core';\nimport { Geometry, Position } from './perfect-scrollbar.interfaces';\nimport { PERFECT_SCROLLBAR_CONFIG, PerfectScrollbarConfig, PerfectScrollbarEvents } from './perfect-scrollbar.interfaces';\nimport * as i0 from \"@angular/core\";\nexport let PerfectScrollbarDirective = /*#__PURE__*/(() => {\n  class PerfectScrollbarDirective {\n    constructor(zone, differs, elementRef, platformId, defaults) {\n      this.zone = zone;\n      this.differs = differs;\n      this.elementRef = elementRef;\n      this.platformId = platformId;\n      this.defaults = defaults;\n      this.instance = null;\n      this.ro = null;\n      this.timeout = null;\n      this.animation = null;\n      this.configDiff = null;\n      this.ngDestroy = new Subject();\n      this.disabled = false;\n      this.psScrollY = new EventEmitter();\n      this.psScrollX = new EventEmitter();\n      this.psScrollUp = new EventEmitter();\n      this.psScrollDown = new EventEmitter();\n      this.psScrollLeft = new EventEmitter();\n      this.psScrollRight = new EventEmitter();\n      this.psYReachEnd = new EventEmitter();\n      this.psYReachStart = new EventEmitter();\n      this.psXReachEnd = new EventEmitter();\n      this.psXReachStart = new EventEmitter();\n    }\n    ngOnInit() {\n      if (!this.disabled && isPlatformBrowser(this.platformId)) {\n        const config = new PerfectScrollbarConfig(this.defaults);\n        config.assign(this.config); // Custom configuration\n        this.zone.runOutsideAngular(() => {\n          this.instance = new PerfectScrollbar(this.elementRef.nativeElement, config);\n        });\n        if (!this.configDiff) {\n          this.configDiff = this.differs.find(this.config || {}).create();\n          this.configDiff.diff(this.config || {});\n        }\n        this.zone.runOutsideAngular(() => {\n          this.ro = new ResizeObserver(() => {\n            this.update();\n          });\n          if (this.elementRef.nativeElement.children[0]) {\n            this.ro.observe(this.elementRef.nativeElement.children[0]);\n          }\n          this.ro.observe(this.elementRef.nativeElement);\n        });\n        this.zone.runOutsideAngular(() => {\n          PerfectScrollbarEvents.forEach(eventName => {\n            const eventType = eventName.replace(/([A-Z])/g, c => `-${c.toLowerCase()}`);\n            fromEvent(this.elementRef.nativeElement, eventType).pipe(auditTime(20), takeUntil(this.ngDestroy)).subscribe(event => {\n              this[eventName].emit(event);\n            });\n          });\n        });\n      }\n    }\n    ngOnDestroy() {\n      if (isPlatformBrowser(this.platformId)) {\n        this.ngDestroy.next();\n        this.ngDestroy.complete();\n        if (this.ro) {\n          this.ro.disconnect();\n        }\n        if (this.timeout && typeof window !== 'undefined') {\n          window.clearTimeout(this.timeout);\n        }\n        this.zone.runOutsideAngular(() => {\n          if (this.instance) {\n            this.instance.destroy();\n          }\n        });\n        this.instance = null;\n      }\n    }\n    ngDoCheck() {\n      if (!this.disabled && this.configDiff && isPlatformBrowser(this.platformId)) {\n        const changes = this.configDiff.diff(this.config || {});\n        if (changes) {\n          this.ngOnDestroy();\n          this.ngOnInit();\n        }\n      }\n    }\n    ngOnChanges(changes) {\n      if (changes['disabled'] && !changes['disabled'].isFirstChange() && isPlatformBrowser(this.platformId)) {\n        if (changes['disabled'].currentValue !== changes['disabled'].previousValue) {\n          if (changes['disabled'].currentValue === true) {\n            this.ngOnDestroy();\n          } else if (changes['disabled'].currentValue === false) {\n            this.ngOnInit();\n          }\n        }\n      }\n    }\n    ps() {\n      return this.instance;\n    }\n    update() {\n      if (typeof window !== 'undefined') {\n        if (this.timeout) {\n          window.clearTimeout(this.timeout);\n        }\n        this.timeout = window.setTimeout(() => {\n          if (!this.disabled && this.configDiff) {\n            try {\n              this.zone.runOutsideAngular(() => {\n                if (this.instance) {\n                  this.instance.update();\n                }\n              });\n            } catch (error) {\n              // Update can be finished after destroy so catch errors\n            }\n          }\n        }, 0);\n      }\n    }\n    geometry(prefix = 'scroll') {\n      return new Geometry(this.elementRef.nativeElement[prefix + 'Left'], this.elementRef.nativeElement[prefix + 'Top'], this.elementRef.nativeElement[prefix + 'Width'], this.elementRef.nativeElement[prefix + 'Height']);\n    }\n    position(absolute = false) {\n      if (!absolute && this.instance) {\n        return new Position(this.instance.reach.x || 0, this.instance.reach.y || 0);\n      } else {\n        return new Position(this.elementRef.nativeElement.scrollLeft, this.elementRef.nativeElement.scrollTop);\n      }\n    }\n    scrollable(direction = 'any') {\n      const element = this.elementRef.nativeElement;\n      if (direction === 'any') {\n        return element.classList.contains('ps--active-x') || element.classList.contains('ps--active-y');\n      } else if (direction === 'both') {\n        return element.classList.contains('ps--active-x') && element.classList.contains('ps--active-y');\n      } else {\n        return element.classList.contains('ps--active-' + direction);\n      }\n    }\n    scrollTo(x, y, speed) {\n      if (!this.disabled) {\n        if (y == null && speed == null) {\n          this.animateScrolling('scrollTop', x, speed);\n        } else {\n          if (x != null) {\n            this.animateScrolling('scrollLeft', x, speed);\n          }\n          if (y != null) {\n            this.animateScrolling('scrollTop', y, speed);\n          }\n        }\n      }\n    }\n    scrollToX(x, speed) {\n      this.animateScrolling('scrollLeft', x, speed);\n    }\n    scrollToY(y, speed) {\n      this.animateScrolling('scrollTop', y, speed);\n    }\n    scrollToTop(offset, speed) {\n      this.animateScrolling('scrollTop', offset || 0, speed);\n    }\n    scrollToLeft(offset, speed) {\n      this.animateScrolling('scrollLeft', offset || 0, speed);\n    }\n    scrollToRight(offset, speed) {\n      const left = this.elementRef.nativeElement.scrollWidth - this.elementRef.nativeElement.clientWidth;\n      this.animateScrolling('scrollLeft', left - (offset || 0), speed);\n    }\n    scrollToBottom(offset, speed) {\n      const top = this.elementRef.nativeElement.scrollHeight - this.elementRef.nativeElement.clientHeight;\n      this.animateScrolling('scrollTop', top - (offset || 0), speed);\n    }\n    scrollToElement(element, offset, speed) {\n      if (typeof element === 'string') {\n        element = this.elementRef.nativeElement.querySelector(element);\n      }\n      if (element) {\n        const elementPos = element.getBoundingClientRect();\n        const scrollerPos = this.elementRef.nativeElement.getBoundingClientRect();\n        if (this.elementRef.nativeElement.classList.contains('ps--active-x')) {\n          const currentPos = this.elementRef.nativeElement['scrollLeft'];\n          const position = elementPos.left - scrollerPos.left + currentPos;\n          this.animateScrolling('scrollLeft', position + (offset || 0), speed);\n        }\n        if (this.elementRef.nativeElement.classList.contains('ps--active-y')) {\n          const currentPos = this.elementRef.nativeElement['scrollTop'];\n          const position = elementPos.top - scrollerPos.top + currentPos;\n          this.animateScrolling('scrollTop', position + (offset || 0), speed);\n        }\n      }\n    }\n    animateScrolling(target, value, speed) {\n      if (this.animation) {\n        window.cancelAnimationFrame(this.animation);\n        this.animation = null;\n      }\n      if (!speed || typeof window === 'undefined') {\n        this.elementRef.nativeElement[target] = value;\n      } else if (value !== this.elementRef.nativeElement[target]) {\n        let newValue = 0;\n        let scrollCount = 0;\n        let oldTimestamp = performance.now();\n        let oldValue = this.elementRef.nativeElement[target];\n        const cosParameter = (oldValue - value) / 2;\n        const step = newTimestamp => {\n          scrollCount += Math.PI / (speed / (newTimestamp - oldTimestamp));\n          newValue = Math.round(value + cosParameter + cosParameter * Math.cos(scrollCount));\n          // Only continue animation if scroll position has not changed\n          if (this.elementRef.nativeElement[target] === oldValue) {\n            if (scrollCount >= Math.PI) {\n              this.animateScrolling(target, value, 0);\n            } else {\n              this.elementRef.nativeElement[target] = newValue;\n              // On a zoomed out page the resulting offset may differ\n              oldValue = this.elementRef.nativeElement[target];\n              oldTimestamp = newTimestamp;\n              this.animation = window.requestAnimationFrame(step);\n            }\n          }\n        };\n        window.requestAnimationFrame(step);\n      }\n    }\n  }\n  PerfectScrollbarDirective.ɵfac = function PerfectScrollbarDirective_Factory(t) {\n    return new (t || PerfectScrollbarDirective)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PLATFORM_ID), i0.ɵɵdirectiveInject(PERFECT_SCROLLBAR_CONFIG, 8));\n  };\n  PerfectScrollbarDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: PerfectScrollbarDirective,\n    selectors: [[\"\", \"perfectScrollbar\", \"\"]],\n    inputs: {\n      disabled: \"disabled\",\n      config: [\"perfectScrollbar\", \"config\"]\n    },\n    outputs: {\n      psScrollY: \"psScrollY\",\n      psScrollX: \"psScrollX\",\n      psScrollUp: \"psScrollUp\",\n      psScrollDown: \"psScrollDown\",\n      psScrollLeft: \"psScrollLeft\",\n      psScrollRight: \"psScrollRight\",\n      psYReachEnd: \"psYReachEnd\",\n      psYReachStart: \"psYReachStart\",\n      psXReachEnd: \"psXReachEnd\",\n      psXReachStart: \"psXReachStart\"\n    },\n    exportAs: [\"ngxPerfectScrollbar\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return PerfectScrollbarDirective;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}